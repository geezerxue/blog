+++
title = "RegExp"
author = ["cl"]
date = 2022-11-27T15:51:00+08:00
lastmod = 2022-11-27T15:51:20+08:00
draft = false
author = "geezer"
+++

## 匹配单个字符 {#匹配单个字符}


### .符号 {#dot-符号}

'.'符号含义为匹配任意字符,包括其本身


### \\符号 {#符号}

'\\'符号为转义字符,能够与特定字符组合产生特殊含义正则表达式中有特殊含义的字符都可以使用'\\'表示其本身的意思例如'.'符号在正则表达式中表匹配任一字符,但若想表示'.'本身这是就能使用'\\.'进行转义了包括'\\'本身也是一样,若想表示'\\'本身则需使用'\\\\'

| 组合 | 描述     |
|----|--------|
| \\\\ | 表示'\\'本身 |
| \\.  | 表示'.'本身 |
| \n   | 表换行符 |
| \t   | 表示制表符 |


## 匹配一组字符 {#匹配一组字符}


### [字符集合]使用 {#字符集合-使用}

[字符集合]中通常包含的是某些字符的集合,其含义为匹配这些字符的其中一个例如:
'[abc]\\.txt'
其匹配结果可以是
a.txt或b.txt或c.txt


### [区间]使用 {#区间-使用}

当我们想匹配字母或数字时,若使用[字符集合]的表示方式就成了[abc...xyz]
这样书写太过麻烦,因此正则表达式提供了一种区间表示方式,它能使用ASCII码的值来表示区间
[a-z]与[abc...xyz]等价
[0-9]与[0123456789]等价注意:区间可以是任意ASCII码从小到大的区间例如:[3-7],[c-f],[F-H]是合法并且由于排序是按ASCII码排序的所以
[1-Z],[1-`]也是合法的因为'1'的ASCII码值为49,而'Z'和'`'的ASCII码值分别为61,90,两者的ASCII的值都比'1'的ASCII码值大,因此是合法的但通常来说这样的表达式也不会怎么出现,使用最多的还是[0-9],[a-z],[A-Z]分别表示数字,所有小写字母和所以大写字母同时[区间]也能同时指定多个区间例如[0-9a-zA-Z]表示所以数字和字母


### ^取反字符 {#取反字符}

'^'字符可配合中括号[]使用,表示匹配不再集合中的字符例如[^0-9]表示匹配不是数字的字符


## 使用元字符 {#使用元字符}

在正则表达式中一个字符的含义不能表示它本身的字符就称为元字符,
前面所学的'.'表任意字符,'['和']'也都是元字符,分别表示字符集合开始和结束它们都没有表示字符本身含义的能力,要想表示其本身就需要用前面学的'\\'字符进行转义


### 匹配空白字符 {#匹配空白字符}

| 元字符 | 描述                    |
|-----|-----------------------|
| [\b] | 回退(并删除)一个字符(BackSpace键) |
| \f   | 分页符                  |
| \r   | 回车符                  |
| \n   | 换行符                  |
| \t   | 制表符                  |
| \v   | 垂直制表符              |


### 匹配特定字符 {#匹配特定字符}


#### 匹配数字 {#匹配数字}

| 元字符 | 描述               |
|-----|------------------|
| \d  | 匹配一个数字(等价于[0-9]) |
| \D  | 匹配一个非数字(等价于[^0-9]) |


#### 匹配数字与字母 {#匹配数字与字母}

| 元字符 | 描述                                |
|-----|-----------------------------------|
| \w  | 匹配一个数字或字母或下划线的字符(等价于[0-9a-zA-Z_]) |
| \W  | 匹配一个非字母,数字,下划线的字符(等价于[^0-9a-zA-Z_]) |


#### 匹配空白字符 {#匹配空白字符}

| 元字符 | 描述                          |
|-----|-----------------------------|
| \s     | 匹配任意一个空白字符(等价于[\f\n\r\t\v]) |
| &sect; | 匹配任意一个非空白字符(等价于[^\f\n\r\t\v]) |


### POSIX字符类 {#posix字符类}

| 字符类     | 描述                       |
|---------|--------------------------|
| [:alnum:]  | 等价于[a-zA-Z0-9]          |
| [:alpha:]  | 等价于[a-zA-Z]             |
| [:blankl:] | 等价于[\t ]                |
| [:cntrl:]  | 匹配ASCII的控制符(0-31加上127) |
| [:digit:]  | 等价于[0-9]                |
| [:graph:]  | 和[:print:]一样,但不包括空格 |
| [:low:]    | 等价于[a-z]                |
| [:print:]  | 任何一个可打印的字符       |
| [:punct:]  | 不属于[:alnum:]和[:cntrl:]的字符 |
| [:space:]  | 等价于[\f\b\r\t\v ]        |
| [:upper:]  | 等价于[A-Z]                |
| [:xdigit:] | 任何一个16进制的数字,等价于[a-fA-f0-9] |

注意:上述POSIX字符类使用时要以'[ ['开头以']]'结尾,即使用双中括号

{{< highlight text >}}
正确写法
[[:alnum:]]
错误写法
[:alnum:]
{{< /highlight >}}


## 重复匹配 {#重复匹配}

当我们想匹配'aaaaa'时,此时我们需要写5个a,如果要匹配更多的a则需要写更多,这样未免太过麻烦因此正则表达式提供了重复匹配的办法


### 常用重复匹配字符 {#常用重复匹配字符}

-   匹配一个或多个字符在字符(或字符集合)后加上 **+** 作为后缀即可,
    例如:[0-9]+ 表示匹配一个或多个数字
-   匹配0个或多个字符使用'\*'字符,用法与'+'字符相同
-   匹配0个或多1个字符使用'?'字符,用法与'+'字符相同


### 重复匹配次数 {#重复匹配次数}

上面所说的元字符依然没办法解决根本问题,例如我们指定就需要将某个字符匹配10次,
这是上面的字符就不能实现了,一次正则表达式提供了可以指定匹配次数的元字符

-   精准匹配次数在字符(或字符集合)后加上'{匹配次数}'即可实现精准的匹配次数例如:a{5} 表示匹配5个a
-   为匹配次数设置区间使用'{最小匹配次数,最大匹配次数}'
-   至少重复几次
    {最少匹配次数,}
    {3,}表示最少重复3次


### 防止过度匹配 {#防止过度匹配}

在HTML中若我们需要对一个标签中的内容进行匹配,
例如:匹配以下html代码中两个p标签内容

{{< highlight html >}}
fsdaf<p>aaaaa</p>
fsdfds<p>bbbbb</p>fdsffd
{{< /highlight >}}

若利用前面所学的内容我们可以写出对应的正则表达式
'&lt;[pP]&gt;.\*&lt;/[pP]&gt;'
然而此正则表达式匹配的内容为

{{< highlight text >}}
<p>aaaaa</p>
fsdfds<p>bbbbb</p>
{{< /highlight >}}

显然与我们预期结果不符,这是因为前面所学的'+','\*','{n, }'都属于'贪婪型'匹配字符,即他们会尽可能匹配多的字符,
而我们现在需要让他们匹配到一个就结束,而不是一直匹配到结尾,此时就需要用到'惰性型'匹配字符',前面列出的'贪婪型'匹配字符,都有对应的'惰性型'匹配字符的版本

| 贪婪型元字符 | 惰性型元字符 |
|--------|--------|
| \*     | \*?    |
| +      | +?     |
| {n, }  | {n, }? |


## 位置匹配 {#位置匹配}


### 单词边界 {#单词边界}

-   适用场景当我们需要精准匹配一个单词时可以用'\b'作为单词的边界(即单词的开始和结尾)像'\b单词\b'这样
-   例1
    但我们需要匹配单词'cat'时,而不希望匹配到'scatter'这类含有'cat'字串的单词此时就可以用'\bcat\b'
-   注意
    '/b'它会匹配一个能够构成单词的字符(数字,字母,下划线)和一个不能构成单词的位置之间
-   例2
    this cat scatter his food
    此时文本中'cat'的'c'和't'这两位置本身是个字母,所以它是个能构成单词的位置,
    而'c'的前面和't'的后面是一个空格,属于不能构成单词的位置,所以若使用'\bcat\b'
    则'\b'的位置分别会位于'cat'和其前面的空格之间,和'cat'和其后面的空格之间
-   例3
    this - nine-digit test
    若此时我们想匹配以空格作为边界的'-'字符,此时若使用'\b-\b'它将匹配'nine-digit'中的'-'
    因为此时'nine-digit'中的'-',其本身是个不能构成单词的字符,而其前后又都是能够构成单词的字符'e'和'd'
    所以'\b-\b'中的'\b'将分别位于'e'和'-'之间和'-'和'd'之间,
    而对于文本中单独的那个'-'由于其本身是个不能构成单词的字符,而其前后又都是空格(不能够构成单词的字符)所以不能匹配那么如何匹配到文本中的单个'-'呢?
-   \B边界对于上面的例子,若想匹配单个'-'则可以使用'\B'作为单词的边界
    '\B'匹配前后都不是一个能够成单词的位置


### 字符串边界 {#字符串边界}

-   ^符号
    '^'表示匹配文本开头
-   \\(符号
        '\\)'表示匹配文本结尾

在我们使用的地方最常用的就是xml文档校验了因为xml文档通常以&lt;?xml ... ?&gt;开头此时我们可以使用正则表达式校验xml文档是否规范
'^\s\*&lt;\\?xml.\*?\\?&gt;'使用该正则表达式即可实现其中'^\s\*'表示允许文档开头有空格换行等空白字符,再者就是注意要使用'惰性型'匹配符其次我们可以用于检验html文件的结束标志使用'&lt;/[hH][tT][mM][lL]&gt;\s\*$'即可


#### 分行匹配模式 {#分行匹配模式}

上述的'^'和'\\('不仅可以匹配文档开头和结尾,在特殊元字符的帮助下可以使其作用改变为匹配一行的开头和结尾这个元字符就是'(?m)',在正则表达式的最前面加上该元字符,就会使得原来正则表达式将整篇文档作为一个字符串而使用该元字符后会将每行作为一个字符串从而实现上述效果示例:检测C语言中的注释
'(?m)^\s\*//.\*\\)'可以实现检测C语言注释


## 使用子表达式 {#使用子表达式}


### 子表达式 {#子表达式}

设想我们需要使得一个单词(例如cat)出现的次数,此时就可以使用子表达式'()'即括号,将cat括起来即(cat),然后在使用前面学的重复匹配即可例如我们希望'cat'出现10次,那么就可以使用'(cat){10}'来实现同时子表达式也支持'|'或操作符,
例如我们希望'cat'或'dog'出现10次,那么就可以使用'(cat|dog){10}'来实现


### 子表达式嵌套 {#子表达式嵌套}

子表达式也支持嵌套操作,这里拿一个ip地址校验举例
(((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5]))\\.){3}(((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5])))


## 回溯应用 {#回溯应用}


### 回溯引用匹配 {#回溯引用匹配}

在正则表达式中存在一个元字符'\\编号'可以引用前面子表达式匹配的内容其中'\\1'表示引用第一个子表达式匹配的内容,'\\2'表示引用第二个子表达式匹配的内容,以此类推例如:在html中我们希望找到div标签的内容
&lt;(div)&gt;.\*?&lt;/\\1&gt;
此表达式中'\\1'就代表第一个子表达式匹配的内容,由于此表达式的第一个子表达式为'(div)',
匹配的是'div'所以'\\1'处其实就代表匹配'div'


## 前后查找 {#前后查找}

在html中我们有时需要获取一个标签的内容而包含标签本身,拿div举例来说我们需要获取div标签中的内容,但内容又不包含div标签本身(即&lt;div&gt;和&lt;/div&gt;)
换句话说我们需要用div标签来匹配内容,但我们又不希望div标签出现在匹配结果中这时就可以使用前后查找


### 向前查找 {#向前查找}

向前查找一个必须匹配但不在返回结果中的的模式其使用方式为一个子表达式以'?='开头'
例如:我们希望提取一下文本中url协议

{{< highlight text >}}
https://www.baidu.com
http://www.google.com
ftp://jfdslakjf
{{< /highlight >}}

分析:此时我们匹配':'前的文本,所以我们需要使用':'来匹配我们需要的内容,但我们又不希望':'出现在匹配结果中此时就可以使用向前查找
.+(?=:)
(?=:)就可以表示用':'匹配但':'又不在匹配结果中


### 向后查找 {#向后查找}

向后查找使用'?&lt;=',使用方式与向前查找一样,但效果相反


### 向前向后结合查找 {#向前向后结合查找}

使用向前向后结合查找,就能实现本章前面说的查找div标签中的内容例如:查找以下文本div标签的内容

{{< highlight html >}}
  <html>
    <body>
      fsdfa
      <div>aaaaaaaaaa</div>
              <div>bbbbbbbbbbbb</div>
      <div>ccccccccccccccc</div>
      </body>
</html>
{{< /highlight >}}

表达式:(?&lt;=&lt;div&gt;).\*?(?=&lt;/div&gt;)
匹配结果:
aaaaaaaaaa
bbbbbbbbbbbb
ccccccccccccccc


### 前后查找取非 {#前后查找取非}

取非即查找不与给定模式匹配的内容,向前向后查找与其取非的操作符如下

| 操作符   | 说明    |
|-------|-------|
| (?=)     | 向前查找 |
| (?!)     | 向前查找的取非 |
| (?&lt;=) | 向后查找 |
| (?&lt;!) | 向后查找取非 |

例如:找出不义'$'开头的数字

{{< highlight text >}}
i paid $100 for 80 apple 50 orange
and 60 pear
i save $20  on this order
{{< /highlight >}}

此时若我们使用向后查找
\b(?&lt;=\\\\()\d+\b
将匹配100和20,因为我们查找的是以'\\)'开头的数字而若使用其取反的版本
\b(?&lt;!\\$)\d+\b
将匹配80,50和60


## 嵌入条件 {#嵌入条件}

条件表达式用'?'符号表示,虽然前面学过'?'表达式可用于表示字符出现0次或1次但这并不影响使用,因为使用条件表达式的情况就两种

1.  在回溯引用中使用
2.  在前后匹配中使用


### 回溯引用条件 {#回溯引用条件}

在北美的电话号码中(123)456-7890,123-456-7890都是正确的而若想实现匹配这个电话号码的正则表达式就可以用到回溯条件解析:我梦可以将上面电话理解为若开头出现了'(',那么第5个字符就必须匹配一个')'
若开头没有'('则电话的第4个字符匹配'-'
其使用方式为(?(backreference)true-regexp[|false-regexp])
其中backreference为一个回溯引用,而true-regexp则是当其前面的回溯引用存在时才会执行的表达式而中括号中的内容可有可无,它表示如果前面回溯引用不存在是执行的表达式这样我们就能解决电话号码这个问题
(\\()?\d{3}(?(\1)\\)|-)\d{3}-\d{4}


### 前后匹配条件 {#前后匹配条件}

格式:(?(前后匹配条件)true|false)


## 常用元字符 {#常用元字符}

[常用元字符](/ox-hugo/regexp.png)
