#+hugo_base_dir: ~/workspace/hugoBlog
#+hugo_section: post
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :author "geezer"
#+hugo_code_fence: nil
#+STARTUP: logdrawer

* Blog Ideas
** DONE shell
CLOSED: [2022-11-18 五 22:28]
:PROPERTIES:
:EXPORT_FILE_NAME: shell
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-18 五 22:28]
:END:
*** 基本bash shell命令
1. more命令
   用于浏览文件,实现了基本的翻页功能
2. less命令
   可以理解为more的升级版,但实际上与more命令相差不大
3. tail命令
   查看文件尾部的几行内容
4. head命令
   与tail命令相反
*** 更多bash shell命令
**** 进程相关命令
1. ps命令
   Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数：
     Unix风格的参数，前面加单破折线(-)
     BSD风格的参数，前面不加破折线
     GNU风格长参数,前面加双破折号(--)
   * unix风格的参数
      | 参数 | 功能                                                   |
      |------+--------------------------------------------------------|
      | -A   | 显示所有进程                                           |
      | -N   | 显示与指定参数不符的所有进程                           |
      | -a   | 显示除控制进（session leader）和无终端进程外的所有进程 |
      | -d   | 显示除控制进程外的所有进程                             |
      | -e   | 显示所有进程                                           |
      | -C   | cmdlist显示包含在cmdlist列表中的进程                   |
      | -G   | grplist显示组ID在grplist列表中的进程                   |
      | -U   | userlist显示属主的用户ID在userlist列表中的进程         |
      | -s   | sesslist                                               |
      | -t   | ttylist显示终端ID在ttylist列表中的进程                 |
      | -u   | userlist显示有效用户ID在userlist列表中的进程           |
      | -F   | 显示更多额外输出（相对-f参数而言）                     |
      | -O   | format显示默认的输出列以及format列表指定的特定列       |
      | -M   | 显示进程的安全信息                                     |
      | -c   | 显示进程的额外调度器信息                               |
      | -f   | 显示完整格式的输出                                     |
      | -j   | 显示任务信息                                           |
      | -l   | 显示长列表                                             |
      | -o   | format仅显示由format指定的列                           |
      | -y   | 不要显示进程标记（processflag，表明进程状态的标记）    |
      | -Z   | 显示安全标签（security context）①信息                 |
      | -H   | 用层级格式来显示进程（树状，用来显示父进程）           |
      | -n   | namelist定义了WCHAN列显示的值                          |
      | -w   | 采用宽输出模式，不限宽度显示                           |
      | -L   | 显示进程中的线程                                       |
      | -V   | 显示ps命令的版本号                                     |
2. kill命令
**** 文件相关命令
***** grep基本使用
****** 反向搜索
查找没有字母"t"的行
grep -v t filename
****** 显示查找内容的行号
查找t所在的行并显示行号
grep -n t filename
****** 统计搜索结果的行数
统计搜索结果中含有字母"t"的行数
grep -c t filename
****** 使用多种搜索模式
查找含"t"或含"f"的行
grep -e t -e f filename
*** linux文件管理系统
**** linux基本文件系统
***** ext
*** shell编程基础
**** 构建基本脚本
***** 创建shell脚本文件
在shell脚本文件中用'#'表示注释,但第一行却是个例外,一般shell的第一行为
#+begin_src shell
#!/bin/bash
#+end_src
这一行告诉shell用哪个shell来运行脚本,当然这里的bash只是一个示例,你也可以用其他的shell.
除第一行外,其他行若以'#'开头则只起注释作用不做任何解释.
***** 变量
在shell中若要使用变量则需要在变量名前加'$'才可以被解释为一个变量,
否则会被解释为普通字符串,若要输出'$'则可以使用'\$'
在shell中变量命名的规则为字母,数字,下划线且长度不能超20个字符,变量
名是区分大小写的.
- 变量创建
  变量创建只需使用变量名后加'='即可
  赋值也与变量创建方法相同
  注意:
  若要将一个变量赋值给其他变量,则必须要有'$',否则会被解释为字符串
  变量名和'='以及值之间不能有空格
  #+begin_src shell
    value1=fsdfd

    value2=$value1
  #+end_src
***** 命令替换
通常来说,若想获得一条命令的输出,可使用反引号'`'或者'$()',
#+begin_src shell


#+end_src
***** 重定向输入输出
- 输出重定向
  其基本功能是将命令的输出写到指定文件中,
  * 格式:
    ls(仅做示范,使用其他命令均可) > 文件名
    ls >> 文件名
  符号'>'表示覆盖文件
  符号'>>'表追加
- 输入重定向
  输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令.
  * 格式:
    wc < 文件名
  wc是一个统计文本的命令,它会计算出文本的行数,词数,及字节数
  上面示例的含义即为统计文件的行数,词数,字节数
  * 格式2
    wc << 标记
  这种格式成为内联输入重定向,它的使用需要一个标记,作为文本的结尾标记
  * 例如
    $ wc << EOF
    > test string 1
    > test string 2
    > test string 3
    > EOF
***** 管道
其含义是将一个命令的输出作为另一个命令的输入,
利用重定向的方式可表示为:
#+begin_example
ls  -U  >  temp
sort  <  temp
#+end_example
示例含义为将ls的不排序的输出结构写到temp文件,在用sort对temp文件排序输出\
但linux提供了更简便的方式
即我们可以利用'|'符号:
#+begin_example
ls -U  | sort
#+end_example
这命令与上面的功能相同,并且还不需要中间文件
***** 使用数学表达式
若要在shell中使用数学表达式则需要使用关键字'expr 表达式'或则使用'$[表达式]'
- 示例
  #+begin_example
expr  4 / 2
$[4 / 2]
  #+end_example
上面描述的两种数学表达式的使用都不支持浮点数运算
解决此问题最常用的是使用bash计算器bc,它能够识别数字,变量,注释,表达式,编程语句,函数
而bc中存在内置变量scale它可以控制浮点数输出的位数,若为它赋值则默认为0,即不保留小数位
利用其那面学的管道,我们就可以实现在shell脚本中使用bc
#+begin_example
var1=$(echo  "scale=4;10/3" |   bc)
#+end_example
但如果是比较长的计算使用这种方法非常的麻烦,
所以我们可以使用前面所学的内联重定向输入'<<'
#+begin_src shell
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc << EOF
scale = 4
a1 = ( $var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
)
#+end_src
***** 退出脚本
- 退出码
  Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。
  | 状态码 | 描述                             |
  |--------+----------------------------------|
  |      0 | 命令成功结束                     |
  |      1 | 一般性未知错误                   |
  |      2 | 不适合的shell命令                |
  |    126 | 命令不可执行(一般为没有执行权限) |
  |    127 | 没找到命令                       |
  |    128 | 无效的退出参数                   |
  |  128+x | 与Linux信号x相关的严重错误       |
  |    130 | 通过Ctrl+C终止的命令             |
  |    255 | 正常范围之外的退出状态码         |
- exit命令
  exit命令在脚本中可用于返回自己定义的退出码,一般来说shell脚本会返回最后一个命令
  执行所返回的退出码,而使用exit可以自己返回一个自定义的退出码
  #+begin_example
命令开始
.
.
.
命令结束
exit 8
  #+end_example
  使用示例中的代码就可以实现返回自定义的退出码,示例中返回的是8
**** 使用结构化命令
***** if使用
if后可以接受一个命令,if会根据命令的退出码来判断执行的分支,
退出码为0即命令正确执行,则执行then后的命令集,否则不执行或执行其他分支
基本使用方式如下
#+begin_src shell
   #!/bin/bash

   #形式1
   if 命令
   then
   ...
   fi

   #形式2
   if 命令
   then
  ...
   else
   ...
   fi
   #形式3
   if 命令
   then
   ...
   elif
   then
   ...
   else
   ...
   fi
#+end_src
***** test命令
由于if语句后面只能通过命令的退出码来判定执行分支,使得if使用很不方便
test命令就可以实现类似于其他编程语言的if判断规则,它的工作原理是但test命令中
所执行的条件如果为真则返回状态码0,使得then可以执行,否则返回非0状态码,执行其他分支
其基本能形式为:
#+begin_src shell
  if test 条件
then
  ...
  fi
#+end_src
也可以在if后面加'[条件]'来判断,这与test的功能是一样的
#+begin_src shell
if  [条件]
then
...
fi
#+end_src
- test数值比较
  | 比较        | 描述                   |
  |-------------+------------------------|
  | n1  -eq  n2 | 检查n1是否与n2相等     |
  | n1  -ge n2  | 检查n1是否大于或等于n2 |
  | n1 -gt n2   | 检查n1是否大于n2       |
  | n1 -le n2   | 检查n1是否小于或等于n2 |
  | n1 -lt  n2  | 检查n1是否小于n2       |
  | n1 -ne  n2  | 检查n1是否不等于n2     |
- test字符串比较
  | 比较         | 描述                   |
  |--------------+------------------------|
  | str1 = str2  | 检查str1是否和str2相同 |
  | str1 != str2 | 检查str1是否和str2不同 |
  | str1 < str2  | 检查str1是否比str2小   |
  | str1 > str2  | 检查str1是否比str2大   |
  | -n str1      | 检查str1的长度是否非0  |
  | -z str1      | 检查str1的长度是否为0  |
- test文件比较
  | 比较            | 描述                                     |
  |-----------------+------------------------------------------|
  | -d file         | 检查file是否存在并是一个目录             |
  | -e file         | 检查file是否存在                         |
  | -f file         | 检查file是否存在并是一个文件             |
  | -r file         | 检查file是否存在并可读                   |
  | -s file         | 检查file是否存在并非空                   |
  | -w filed        | 检查file是否存在并可写                   |
  | -x file         | 检查file是否存在并可执行                 |
  | -O file         | 检查file是否存在并属当前用户所有         |
  | -G file         | 检查file是否存在并且默认组与当前用户相同 |
  | file1 -nt file2 | 检查file1是否比file2新                   |
  | file1 -ot file2 | 检查file1是否比file2旧                   |
***** 复合条件测试
if语句支持使用布尔值进行复合测试
#+begin_example
if  [ condition1 ] && [ condition2 ]
then
...
fi


if  [ condition1 ] || [ condition2 ]
then
...
fi
#+end_example
***** if高级特征
- 使用双括号
  双括号可以理解为是test数值检测的升级版,在双括号内不仅可以使用test的数值检测
  能使用的表达式
  还能使用一些其他常用的运算符
  | 符号   | 功能     |
  |--------+----------|
  | val++  | 后增     |
  | val--  | 后减     |
  | ++val  | 先增     |
  | --val  | 先减     |
  | !      | 逻辑求反 |
  | ~      | 位求反   |
  | \**    | 幂运算   |
  | <<     | 左位移   |
  | >>     | 右位移   |
  | &      | 位布尔和 |
  | 竖线   | 位布尔或 |
  | &&     | 逻辑和   |
  | 双竖线 | 逻辑或   |
- 双方括号
  双括号只能对进行数学表达是运算,通俗来说就是运算对象只能是数值
  而双方括号则是test检测字符串的升级
  它提供了模式匹配功能,并且可以使用正则表达式进行匹配
***** case命令
其功能类似于switch
#+begin_src shell
case v in
p1 | p2) commands1;;
p3) commands2;;
*) default commands;;
esac
#+end_src
其含义为若变量v与p1或p2匹配则执行commands1
若与p3匹配则执行commands2
若都不满足则执行commands
***** for语句
#+begin_src shell
  list="a b c d"
    for var in list
    do
        echo "--$var"
    done
#+end_src
上面语句会输出
#+begin_example
--a
--b
--c
--d
#+end_example
这是因为for会自动对list进行分割,在shell中存在一个IFS环境变量定义了
shell用作字段分隔符的一系列字符,默认情况下shell会将空格,制表符,换行符作为分割符
同时,通过修改IFS变量可以修改分割规则
#+begin_src shell
IFS="/"
list="a/b/c"
for val in list
do
    echo  "$val"
done
#+end_src
上面示例shell会将'/'作为分隔符,及会依次换行输出a,b,c而'//'作为分隔符不会输出
***** C语言风格的for
#+begin_src shell
for (( a = 1; a < 10; a++ ))
do
...
done
#+end_src
***** whle语句
- 从10输出到1
      #+begin_src shell
        var1=10
          while [ $var1 -gt 0 ]
          do
          echo $var1
          var1=$[ $var1 - 1 ]
#+end_src
- while使用多个测试命令
  #+begin_src shell
#!/bin/bash
# testing a multicommand while loop10
var1=1011
while echo $var1
[ $var1 -ge 0 ]
do
echo "This is inside the loop"
  #+end_src
  示例中的while后有两个测试语句,但while将最后一个语句的退出码做判断
  而位于它前面的语句只做执行,不用做while的判断
***** unit语句
与while语法相同但作用相反,只有测试语句的退出码返回0才会退出until
#+begin_src shell
until   条件
do
...
done
#+end_src
***** 循环控制
- break
  与C语言的break功能相似,但shell中的break可以指定参数
  来表示退出的循环的级别,默认是1即退出当前循环
- continue
  与C语言的continue功能相似,不过它也能指定参数表示要继续执行的循环的级别
**** 处理用户输入
***** 参数
在shell脚本中用$0表运行的程序,$1表第一个参数,$2表第二个参数依次类推
***** 特殊参数变量
- $#表示传入shell中的参数个数
- $*和$@变量可以用来轻松访问所有的参数
  两者都会将所有传给shell的变量作为它的值
  $*会将所有传给shell的参数当作整体处理
  $@则可以单独处理
  即在使用for时,如果将$*作为list则不会对其中包含的变量进行拆分
  而$@则可以
***** 移动参数
shift命令可以实现移动参数,即shfit可以将所有参数(不包括$0)往左移动
也就是使用shift后$1的值会等于$2,$2会等于$3,以此类推,而$1初始值会被丢弃
***** 获得用户输入
基本格式:read  name
将用户输入的内容复制给name
** DONE emacslisp
CLOSED: [2022-11-18 五 22:28]
:PROPERTIES:
:EXPORT_FILE_NAME: emacslisp
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-18 五 22:28]
:END:
*** emacs tutorial
*** emacs init
*** emacs keys
  介绍一些emacs的快捷键,以及如何定义快捷键
**** 定义快捷键
- 定义全局快捷键
  将crtl-b绑定到whitespace-mode上
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-b") 'whitespace-mode)
  #+end_src
- 定义局部快捷键
  局部快捷键只对当前buffer有效,一旦离开当前buffer则会失效
  #+begin_src emacs-lisp
    (local-set-key (kbd "C-b") 'whitespace-mode)
  #+end_src
- 取消某个快捷键
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-b") nil)
  #+end_src
**** 定义快捷键的语法
- 单个修饰键和单个特殊键
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-a") 'backward-char) ; Alt+a
    (global-set-key (kbd "C-a") 'backward-char) ; Ctrl+a
    (global-set-key (kbd "<f3>")  'backward-char) ; F3 key
  #+end_src
- 定义带前缀的快捷键
  当定义某个带前缀的快捷键时需要先取消前缀快捷键的绑定.
  #+begin_src emacs-lisp
    (global-set-key (kbd "<f7>") nil) ; good idea to put nil to the starting key
    (global-set-key (kbd "<f7> <f8>") 'calendar)

    (global-set-key (kbd "C-e") nil) ; good idea to put nil to the starting key
    (global-set-key (kbd "C-e a") 'calendar) ; Ctrl+e a
    (global-set-key (kbd "C-e SPC") 'calendar) ; Ctrl+e Space
  #+end_src
**** 在major-mode中添加快捷键
- 普通方法
   要在某个major-mode上添加快捷键使其只作用于该major-mode,
   其主要原理是在该major-mode上添加hook,使得在开启该major-mode
   后调用我们自定义的函数,而自定义的函数中我们可以定义一个局部快捷键
   这样就可以时的该快捷键只对该major-mode有效
   #+begin_src emacs-lisp
     (when (fboundp 'go-mode)
       (defun my-go-config ()
         "为go-mode添加快捷键"
         (local-set-key (kbd "C-b") 'gocf)
         ;;其他配置)
       (add-hook 'go-mode-hook 'my-go-config))
   #+end_src
- 直接修改mode的键位映射
  如果我们知道某个major-mode的键位映射变量名,则可以直接通过变量名修改
  #+begin_src emacs-lisp
  (progn
  ;; modify dired keys
    (require 'dired )
    (define-key dired-mode-map (kbd "o") 'other-window)
    (define-key dired-mode-map (kbd "2") 'delete-window)
    (define-key dired-mode-map (kbd "3") 'delete-other-windows)
    (define-key dired-mode-map (kbd "4") 'split-window-below)
    (define-key dired-mode-map (kbd "C-o") 'find-file))
  #+end_src
**** 在minor-mode中添加快捷键
   minor-mode的键位映射变量名,一般都是'minor-mode名-mode-map',所以要为某个
   minor-mode添加快捷键可以
   #+begin_src emacs-lisp
  (progn
  ;; change isearch's keys to arrows
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )

  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)
  )
   #+end_src
**** minor-mode的快捷键优先级
   minor-mode的快捷键优先级存放在 *minor-mode-map-alist*
   它是一个关联列表,可通过修改该变量来修改minor-mode优先级
**** 定义快捷键前缀
#+begin_src elisp
  ;;定义快捷键前缀命令
  (define-prefix-command 'geezer-prefix)
  ;;将以上命令绑定到某个快捷键上
  (global-set-keys (kbd "C-z") 'geezer-prefix)
  ;;经过以上两步就可以是的'C-z'成为一个前缀按键
  ;;之后只需要在该前缀按键添加即可
  (define-key my-keymap (kbd "<f6>") 'visual-line-mode)
#+end_src
**** 同一个命令在不同major-mode的不同作用
   要是同一个命令在不同major-mode中的作用不同,最简单的方法就是封装该命令,
   再在命令中判断当前major-mode
   假设我们在x1-mode时执行该命令会调用x1-cmd
   在x2-mode时,为x2-cmd
   #+begin_src elisp
     ;;定义x1-cmd函数和x2-cmd函数
     (defun x1-cmd () ())
     (defun x2-cmd () ())

     (defun geezer-smart-cmd ()
       (interactive)
       (cond
        ((string-equal major-mode "x1-mode") (x1-cmd))
        ((string-equal major-mode "x2-mode") (x2-cmd))
        (t nil)
       ))
   #+end_src
**** 定义可临时重复使用的快捷键
   在emacs有这样的操作,调用某个命令后就可以重复按住指定键来重复执行该命令,而且这个操作
   是可以中断的,中断后之前的按键就会失效.这就好比在浏览器中我们可以按住ctrl键,然后滚动
   鼠标就能实现放大缩小,而松开ctrl键后就没有这种效果了.
   在emacs也有这样的操作,比如 *text-scale-adjust* 调用该命令后,允许按 *+* 键放大,按 *-*
   键缩小等操作,而结束该命令后就会失去该效果
   下面我们来实现下这个操作
   #+begin_src elisp
     (defun geezer-forward-word ()
       "移动光标"
       (interactive)
       (progn
         (forward-char)
         (set-transient-map
          (let (($kmap (make-sparse-keymap)))
            (define-key $kmap (kbd "r") 'geezer-forward-word)
            (define-key $kmap (kbd "l") 'geezer-backward-word)
            $kmap
            )
          )
         )
       )
     (defun geezer-backward-word ()
       "移动光标"
       (interactive)
       (progn
         (forward-char)
         (set-transient-map
          (let (($kmap (make-sparse-keymap)))
            (define-key $kmap (kbd "r") 'geezer-forward-word)
            (define-key $kmap (kbd "l") 'geezer-backward-word)
            $kmap
            )
          )
         )
       )
   #+end_src
   以上代码中 *set-transient-map* 接受一个keymap,并且使用该keymap一次,并且该keymap的
   优先级会高于其他的minor-mode
   而let中的代码,则返回一个 keymap,使用该keymap后按r或者l都会执行一个递归函数
   以此实现重复调用,这样在调用该函数后,可以重复使用r和l实现对应的操作.按C-g可结束
   也可以自定义一个键位结束,结束后r和l的功能会还原,
**** 在emacs中输入表情,及其他unicode符号
   *key-translation-map* 是emacs自带的一个keymap,在任何buffer都有效
   所以我们可以向里面添加map实现输入表情的效果
   #+begin_src elisp
     (define-key key-translation-map (kbd "<f8>") (kbd "•"))
          ;; set keys to insert math symbol
     (define-key key-translation-map (kbd "<f9> p") (kbd "φ"))
     (define-key key-translation-map (kbd "<f9> x") (kbd "ξ"))
     (define-key key-translation-map (kbd "<f9> i") (kbd "∞"))
     (define-key key-translation-map (kbd "<f9> <right>") (kbd "→"))

     ;; set keys to insert emoji
     (define-key key-translation-map (kbd "<f9> 1") (kbd "😅"))
     (define-key key-translation-map (kbd "<f9> 2") (kbd "❤"))
   #+end_src
   这里不推荐使用 *global-set-key* 的方式,就像下面这种
   #+begin_src elisp
     (global-set-key (kbd "<f8>") (lambda () (interactive) (insert "→")))
   #+end_src
   这种方法的确可行,但在使用isearch时会失效
**** 交换键盘按键
交换f11和f12
#+begin_src emacs-lisp
    (define-key key-translation-map (kbd "<f11>") (kbd "<f12>"))
    (define-key key-translation-map (kbd "<f12>") (kbd "<f11>"))
#+end_src
**** 鼠标操作
- 取消鼠标的加速
  #+begin_src elisp
    (setq mouse-wheel-progressive-speed nil)
  #+end_src
- 控制鼠标每次移动的行数
  是鼠标每次能够移动两行
  #+begin_src elisp
    (setq mouse-wheel-scroll-amount '(2))
  #+end_src
- 取消鼠标高亮
  #+begin_src elisp
    (setq mouse-highlight nil)
  #+end_src
***** 鼠标的语法
| 鼠标按键              | elisp表示            |
|-----------------------+----------------------|
| 鼠标左键              | (kbd "<mouse-1>")    |
| 鼠标滚轮键            | (kbd "<mouse-2>")    |
| 鼠标右键              | (kbd "<mouse-3>")    |
| 鼠标滚轮向前(linux)   | (kbd "<mouse-4>")    |
| 鼠标滚轮向后(linux)   | (kbd "<mouse-5>")    |
| 鼠标滚轮向前(mac,win) | (kbd "<wheel-up>")   |
| 鼠标滚轮向后(mac,win) | (kbd "<wheel-down>") |
*** lisp basics
**** 基础
- 输出函数print
  格式:(print OBJECT &optional PRINTCHARFUN)
  print接受一个输出对象和一个输出的目标buffer
  object即为输出对象,printcharfun即输出的目标buffer
  #+begin_src elisp
  (progn
    (setq gbuffer (generate-new-buffer "*my output*"))
    (print "fasdfs" gbuffer)
    (switch-to-buffer gbuffer))
  #+end_src
- unicode字符表示
  *\uxxxx* :接受四个16进制数
  *\u00xxxxxx* :接受六个16进制数
- 处理字符串的函数
  | 函数             | 示例                            | 作用                        | 结果               |
  |------------------+---------------------------------+-----------------------------+--------------------|
  | length           | (length "abc")                  | 获得"abc"长度               | 3                  |
  | substring        | (substring "abc123" 0 3)        | 截取字符串0-3之间的子字符串 | abc                |
  | concat           | (concat "some" "thing")         | 字符串拼接                  | something          |
  | split-string     | (split-string "xy_007_cat" "_") | 以'_'截取字符串             | ("xy","007","cat") |
  | string-to-number |                                 | 字符串转数字                |                    |
  | number-to-string |                                 | 数字转字符                  |                    |
- 相等判断
  equal:判断数据类型和值是否相同
  eq:判断是否为同一对象
  eql:与eq很像但两个相同的浮点数会返回t
**** 数据类型
- mapcar
  (mapcar FUNCTION SEQUENCE)
  会返回处理后的结果
- mapc
  与mapcar一样但不会返回结果,而返回nil

*** practical emacs lisp
**** 概述
***** 光标位置
| 函数                    | 作用                                               |
|-------------------------+----------------------------------------------------|
| point                   | 返回当前光标位置,其值为前面字符个数,包括空格和回车 |
| region-beginning        | 返回选中区域的开头字符位置                         |
| region-end              | 返回选中区域的结尾字符位置                         |
| line-beginning-position | 返回行首字符位置                                   |
| line-end-position       | 返回行为字符位置                                   |
| point-min               | 返回整个文件开头位置                               |
| point-max               | 返回整个文件结尾位置                               |
***** 光标移动和文本搜索
#+begin_src emacs-lisp
  ;;跳转到39字符的位置
   (goto-char 39)
  ;;使光标前移和后移四个字符
  (forward-char 4)
  (backward-char 4)
  ;;向前搜"some"和向后搜索"some"
  (search-forward "some") ; to end of “some”
  (search-backward "some") ; to beginning of “some”
  ;;向前搜索数字和向后搜索数字
  (re-search-forward "[0-9]") ; digit
  (re-search-backward "[0-9]")
  ;;将光标前移和将光标后移,知道找到非小写字母
  (skip-chars-forward "a-z")
  (skip-chars-backward "a-z")
#+end_src
***** 修改文本
#+begin_src emacs-lisp
  ;;从光标开始删除9个字符
  (delete-char 9)
  ;;删除3-10位置的字符
  (delete-region 3 10)
  ;;在当前光标处插入字符串
  (insert "i ♥ cats")
  ;;获取当前buffer71-300的字符串,并赋值给x
  (setq x (buffer-substring 71 300))

  ;;将7-300处的字母转为大写
  (capitalize-region 71 300)
#+end_src
***** buffer操作
#+begin_src emacs-lisp
  ;;获取buffer名称
  (buffer-name)

  ;;返回当前buffer文件的绝对路径
  (buffer-file-name)

  ;; switch to the buffer named xyz
  (switch-to-buffer "xyz")

  ;;保存当前buffer
  (save-buffer)

  ;; 关闭名为"xyz"的buffer
  (kill-buffer "xyz")

  ;;临时将"xyz"buffer作为当前buffer,函数结束后将返回之前操作的buffer
  (with-current-buffer "practical-elisp.el"
    ;;这里可以写一些插入删除等操作
  )
#+end_src
***** 文件操作
- 基本操作
  #+begin_src emacs-lisp
    ;; open a file (in a buffer)
  (find-file "~/")

  ;; same as “Save As”.
  (write-file path)

  ;; insert file into current position
  (insert-file-contents path)

  ;; append a text block to file
  (append-to-file start-pos end-pos path)

  ;; renaming file
  (rename-file file-name new-name)

  ;; copying file
  (copy-file old-name new-name)

  ;; deleting file
  (delete-file file-name)

  ;; get dir path
  (file-name-directory  full-path)

  ;; get filename part
  (file-name-nondirectory full-path)

  ;; get filename's suffix
  (file-name-extension file-name)

  ;; get filename sans suffix
  (file-name-sans-extension file-name)
  #+end_src
- narrow操作
  narrow操作可以使文件只有指定的部分可见,而其余部分不可见,除此以外它的效果与
  删除效果几乎相同,它会对光标行数等产生影响.可以调用"widen"把刚才隐藏的部分显示出来
  | 函数             | 作用                                      |
  |------------------+-------------------------------------------|
  | narrow-to-defun  | 仅显示当前光标所在的函数                  |
  | narrow-to-page   | 仅显示当前页面中可见的内容                |
  | narrow-to-region | 仅显示指定位置的内容                      |
  | widen            | 显示隐藏部分的内容                        |
  | buffer-narrow-p  | 判断当前buffer是否有隐藏内容              |
  | save-excursion   | 保存当前光标位置,执行完body里的内容后返回 |
  | save-restriction | 保存当前缓冲区,执行完body里的内容后返回通常与narrow一起使用    |
***** 案例
- 替换选中区域的文本
  #+begin_src emacs-lisp
 (defun geezer-replace-greek-region ()
  (interactive)
  (let ((start (region-beginning))
        (end (region-end)))
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward "a" nil t)
        (replace-match "A" nil t))
      (goto-char (point-min))
      (while (search-forward "b" nil t)
        (replace-match "B" nil t)))))
  #+end_src
- 删除括号中的内容
  #+begin_src emacs-lisp
 (defun geezer-delete-pair ()
  (interactive)
  (save-excursion
    (let (p1 p2)
      (skip-chars-backward "^([{<>")
      (setq p1 (point))
      (skip-chars-forward "^)]}<>")
      (setq p2 (point))
      (delete-region p1 p2))))
  #+end_src
***** defun中的interactive的作用
定义函数时interactive的作用有两个
1. 是函数可以以命令的形式调用,及通过M-x的方式
2. 在interactive后加上参数可以是调用该函数时实现交互式传参
****** 参数说明
- (ineractive)
  可以用命令调用
- (ineractive string)
  string第一个字符指定输入的内容,例如为s则表示为输入一个字符串,为n则表示数字等,
  若要从交互界面获取多个参数可以用回车隔开
  #+begin_src emacs-lisp
    (defun ask-name-and-age (x y)
  "Ask name and age"
  (interactive
   "sEnter name
    nEnter age:")
  (message "Name is: %s, Age is: %d" x y))
  #+end_src
- (ineractive list)
  这种方式是最常用的一种方式,list中可以是任何表达式,只要能够返回对应参数个数的list即可
  #+begin_src emacs-lisp
      (defun ask-name-and-age2 (x y)
    "Ask name and age"
    (interactive
     (list
      (read-string "Enter
    name:")
      (read-number "Enter age:")))
    (message "Name is: %s, Age is: %d" x y))
  #+end_src
****** thing-at-point
函数调用:(thing-at-point THING &optional NO-PROPERTIES)
当我们用interactive进行交互时,使用 *thing-at-point* 是非常方便的,
例如,我们在寻求帮助时,使用的describe-function,describe-variable(对应快捷键C-h f,C-h k)时,
就会获取当前光标处的函数或变量,使得我们在调用上面两个命令时,如果我们不做输入,它会默认选择光标处的函数或变量
thing-at-point不仅可以获取当前光标处的函数和变量,同时也可以获取光标处的
'symbol, 'list, 'sexp, 'defun, 'filename, 'url, 'email, 'uuid, 'word, 'sentence, 'whitespace, 'line, 'number, 'page.
只需要将 *thing-at-point* 的第二个参数设为上面这些值即可
#+begin_src emacs-lisp
  (defun test ()
    "获取单词"
    (interactive)
    (message "%s" (thing-at-point 'word)))
#+end_src
****** bounds-of-thing-at-point
获取thing-at-point的边界,返回的是一个cons,其第一个元素为边界的开始的位置,第二个元素为边界结束的位置
#+begin_src emacs-lisp
  (defun test ()
    (interactive)
    (let (bounds pos1 pos2 mything)
      (setq bounds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bounds))
      (setq pos2 (cdr bounds))
      (setq mything (buffer-substring-no-properties pos1 pos2))
      (message
       "thing begin at [%s],end at [%s],thing is [%s]"
       pos1 pos2 mything))
#+end_src
***** 查找替换
- search-forward和search-backward.
  (search-forward STRING &optional BOUND NOERROR COUNT)
  将关闭移动到要查找的字符串开始位置,
- re-search-forward和re-search-backward
  (re-search-forward REGEXP &optional BOUND NOERROR COUNT)
  与上面函数功能一样,不过匹配的是正则表达式,而非字符串
- search-forward-regexp和search-backward-regexp
  分别是re-search-forward和re-search-backward的别名
- case-fold-search变量
  其值默认为t,表示查找是忽略大小写
  为nil时,表示不忽略大小写
**** elisp脚本
***** 运行elisp脚本
elisp可以运行在终端,比如
#+begin_src shell
  emacs --script  /path/to/elisp-file
#+end_src

***** buffer相关函数
- buffer-name
  (buffer-name &optional BUFFER)
  获取当前buffer名字
- buffer-file-name
  (buffer-file-name &optional BUFFER)
  返回当前buffer处文件的绝对路径,如果不存在则返回nil
- with-current-buffer
  (with-current-buffer BUFFER-OR-NAME &rest BODY)
  将某个缓冲区作为临时的缓冲区,执行完body里的内容后返回
- set-buffer
  (set-buffer BUFFER-OR-NAME)
  跳转到指定buffer,但该buffer不可见,如果需要可见可使用switch-to-buffer
- generate-new-buffer
  (generate-new-buffer NAME)
  新建一个buffer
- get-buffer-create
  (get-buffer-create BUFFER-OR-NAME)
  新建一个buffer,但不将其作为当前buffer
- kill-buffer
  (kill-buffer &optional BUFFER-OR-NAME)
  关闭指定buffer
***** 文件相关函数
- directory-files
  返回一个带有该目录下所有指定文件的list
  不会递归查找,即如果该目录下有子目录不会对子目录进行查找
  (directory-files DIRECTORY &optional FULL MATCH NOSORT)
  参数1:目录路径
  参数2:返回的文件是否为绝对路径
  参数3:文件匹配的方式
  参数4:是否排序
- directory-files-recursively
  递归查找指定文件,后返回一个带有所有指定文件的list
  会递归查找,即如果该目录下有子目录会对子目录进行查找
  由于会递归查找所以会返回文件的相对路近,而非只含文件名
  (directory-files-recursively DIR REGEXP &optional INCLUDE-DIRECTORIES)

*** elisp example
*** emacs write major-mode
**** font lock mode
它是emacs内置的一个minor-mode,它与当前buffer的语法高亮有关,其高亮规则通过两种方式实现
1. Syntactic fontification
   一些与注释字符串,符号相关的注释,它的注释内容存放在,Syntax Table中,可通过describe-syntax命令查看
2. Search based fontification
   使用正则表达式查找相关内容进行高亮,通常高亮的是一些关键字,函数名,变量名之类的,它依赖于,font-lock-defaults变量
**** font-lock-defaults
该变量通常是一个list,为nil的话将不会进行任何高亮,而list里面通常有四个关键变量
1. font-lock-keywords
   关键字的高亮规则
2. font-lock-keywords-only
   字符串和注释等的高亮规则
3. font-lock-keywords-case-fold-search
   正则表达式是否区分大小写
4. font-lock-syntax-table
   与syntax有关
** DONE orgmode
CLOSED: [2022-11-18 五 22:28]
:PROPERTIES:
:EXPORT_FILE_NAME: orgmode
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-18 五 22:28]
:END:
*** 文档结构
**** 列表
   * 无序列表
     + 使用"*"号的列表
       由于org中*号可以有两种含义,即标题和列表.所以若要用*号表示列表的话,*号不能位于行首否则就成标题了.
       示例:
       * 列表1
       * 列表2
       * 列表3
     + 使用"+"号或"-"号的列表
       与*号用法基本一致,唯一不同的是可以位于行首
   * 有序列表
     有序列表使用"1."或者"1)"开头
     示例:
     1. 第一
        1) fsdaf
        2) fdsja
     2. 第二
     3. 第三
   * 结束列表
     可以在列表下空两行,结束该列表,或者将内容的缩进修改成小于或等于该列表也可以结束列表.
   * 常用操作与快捷键
     * <tab>
       对列表进行收缩或展开
     * M-RET
       在该列表下方新建一个与该列表同级的列表.
       注意:如果光标位于列表名称的中将的话,则会将该列表后的内容作为新列表.
     * M-S-RET
       在该列表下方新建一个与该列表同级并且带有复选框的列表.其他与M-RET功能相似.
     * S-UP和S-DOWN
     * M-UP和M-DOWN
       移动列表,将列表上移或者下移.移动时会连其下的内容也会随之移动.
     * M-LEFT和M-RIGHT
       提升或者降低列表的级别.不会连同子列表一起移动.
     * M-S-LEFT和M-S-RIGHT
       提升或者降低列表的级别.会连同子列表一起移动
     * C-c C-c
       与复选框相关的操作
     * C-c -
       修改与当前列表同级的表示方式,使它们的表示方式在"-,+,*,1.,1)"中循环切换.如果有选中区域的话则只对该区域内的列表有效.
     * C-c *
       将当前列表修改为标题,使其下与其同级别的列表成为它的子项
     * C-c C-*
       将当前列表级别一致的列表修改为缩进一致的标题.
     * S-LEFT和S-RIGHT
       修改列表与当前列表同级别的表示方式,在"-,+,*,1.,1)"切换.
       注意:使用此操作是需要将光标移动到表示列表的符号上.
     * C-c ^
       对列表进行排序,可以按数字,字母,时间或者自定义函数进行排序.

**** drawer
+ 简介
  drawer里可以保存一些与内容相关的东西,而你又不希望显示他们,就可以使用drawer,这个有点类似于标签的功能.
+ 示例
  :drawer的名称:
  drawer的内容
  :END:
+ 常用操作与快捷键
  * 插入一个drawer
    C-c C-x d
  * 插入一个带有时间的drawer
    C-c C-z

**** block
   - 简介
     block通常用于存放代码块和一些示例,以"#+BEGIN"开头,中间写入内容,以"#+END"结尾.
   - 示例
     + 引用块
       #+BEGIN_QUOTE
        引用内容
       #+END_QUOTE
     + 示例块
       #+Begin_EXAMPLE
        示例
       #+END_EXAMPLE
     + 代码块
       #+begin_src c
         int main()
           {
             int a=;
             float d=0;
             return 0;
             }
       #+end_src
*** 表格
**** 创建表格
- 表格表示
  如果某行是以'|'开头并且非空的花一般会被视为是一个表格,而以'|-'开头则会被视为是一个表格的水平线.
- 示例:
   |   | 1 | 2 | 3 |
   |---+---+---+---|
   | 1 |   |   |   |
   | 2 |   |   |   |
   | 3 |   |   |   |
- 快捷键
  * <tab>
    1. 输入"|"时如果是首字母,按tab会自动生成表格
    2. 输入"|-"时如果是首字母,按tab会自动生成表格的水平线
    3. 当光标在表格中输入tab会将往右移至下一个表格,如果表格已经是最后一个则会移动下一行第一个,如果下一行没有内容则会先在下一行新建一列.
  * S-<tab>
    与<tab>相反,不过只包含移动操作.
  * M-a
    将光标定位的当前格子的最前面,如果光标所在格子没有内容者与<tab>功能相同
  * M-a
    将光标定位的当前格子的最后,如果光标所在格子没有内容者与S-<tab>功能相同
  * RET
    上下移动表格,如果表格已经是最后一行则会在下一行新建一行比表格后载移动下一行第一个
  * C-c | (org-table-create-or-convert-from-region)
    该命令输入后会提示用户输入表格的列x行,输入后会在该区域创建一个这样的表格.如果当前选中的区域是以逗号或者空格分开的,则该命令会按此自动生成表格.
  * C-c C-c
    是当前表格对齐
  * org-table-blank-field
    清空当前光标所处位置的格子中的内容
  * M-LEFT (org-table-move-column-left)和M-RIGHT (org-table-move-column-right)
    将当前列向指定方向移动
  * M-S-LEFT (org-table-delete-column)
    将当前列删除
  * M-S-RIGHT (org-table-insert-column)
    在当前列的前面新建一列
  * M-UP (org-table-move-row-up)和M-DOWN (org-table-move-row-down)
    将当前行向指定方向移动.
  * M-S-UP (org-table-kill-row)
    将当前行删除
  * M-S-DOWN (org-table-insert-row)
    在当前行上面新建一行.
  * 对单个格子移动
    - S-UP (org-table-move-cell-up)
      将当前格子向上移动
    - S-DOWN (org-table-move-cell-down)
      将当前格子向下移动
    - S-LEFT (org-table-move-cell-left)
      将当前格子向左移动
    - S-RIGHT (org-table-move-cell-right)
      将当前格子向右移动
  * C-c - (org-table-insert-hline)
    在当前行下面插入表格的水平线
  * C-c RET (org-table-hline-and-move)
    与C-c -功能一致,不过会移动至新建的水平线下一行表格
  * C-c ^ (org-table-sort-lines)
    对表格进行排序,排序的选择对象为光标所在的列.
  * C-c ` (org-table-edit-field)
    新开一个buffer对当前格子的内容进行编辑
  * M-x org-table-transpose-table-at-point
    将光标所在的表格进行行列互换
  * C-c TAB (org-table-toggle-column-width)
    收缩或者扩张
*** 超链接
**** 创建超链接
   示例:
   #+begin_example
   [[链接][描述]]
   或
   [[链接]]
   #+END_example

**** 链接类型
   - 内部链接
     + 使用id
       跳转到指定id位置
       #+begin_example
       [#custom_id]
       #+end_example
     + 使用章节
       跳转到指定章节
       #+begin_example
       [*section]
       或
       [section]
       #+end_example
     + 定义标记
       跳转到自定义的标记,使用'<<target>>'自定义一个标记
       #+begin_example
       <<target>>
       [target]
       #+end_example
   - 外部链接
     可以打开网址,文件等内容,一般都有自己的格式开头,比如网址以http或https开头,文件以file开头
     #+begin_example
     [[https://www.baidu.com]]
     [[file:/home/cl/]]
     #+end_example

*** todo-item
**** todo的使用
   todo跟标题的使用方式几乎一样,在标题前加上TODO(大写)即可是标题成为一个TODO列表
   #+begin_example
   *** TODO 开会
   #+end_example
***** 常用的快捷键和命令
| 快捷键          | 命令                    | 作用                                                             |
|-----------------+-------------------------+------------------------------------------------------------------|
| C-c C-t         | org-todo                | 切换todo的状态                                                   |
| S-right和S-left |                         | 循环切换todo状态                                                 |
| C-c / t         | org-show-todo-tree      | 将文档中所以的todo项以稀疏树的形式展现出来                       |
| C-c a t         | org-adenda t            | 显示全局 TODO 列表。从所有的议程文件中收集 TODO 项到一个缓冲区中 |
| S-M-RET         | org-insert-todo-heading | 插入一个todo列表                                                 |

**** 完成进度
   可以在标题或者todo列表后加上'[/]'或者'[%]'来其子项todo的完成进度或者复选框的选择比例,按'C-c C-c'可以刷新其状态
***** 示例  [2/4] [50%]
****** DONE 111
CLOSED: [2022-10-29 六 11:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-10-29 六 11:40]
:END:
****** TODO 222
****** TODO 333
****** DONE 444
CLOSED: [2022-10-29 六 11:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-10-29 六 11:41]
:END:
**** 复选框
   复选框是特殊的列表,在列表的名称前加上'[ ]'即是一个复选框
   例如:
***** TODO today arrange [0/3] [0%]
:PROPERTIES:
:ORDERED:  t
:END:
    - [-] call someone [1/3]
      - [ ] peter
      - [ ] lasy
      - [X] jonh
    - [-] order food [2/3]
      - [X] milk
      - [ ] bread
      - [X] dumpling
    - [-] listen music [33%]
      - [ ] jay chou
      - [X] justin biber
      - [ ] mike jackson
***** 操作与快捷键
    - C-c C-c和C-c C-x C-b(org-toggle-checkbox)
      触发复选框的状态
    - C-c C-x C-r (org-toggle-radio-button)
      是得同级的复选框只能选中一个或不选,执行此命令会是同级复选框都处于非选中状态,如果当前复选框是选中的则取消选中,否则选中.
    - M-S-RET (org-insert-todo-heading)
      插入一个新的复选框
*** 标签
  标签是对标题的说明,可以在标题后使用并且一个标题可以含有多个标签,标签的前后都必须有一个冒号
**** 标签的继承
   标签具有继承性,一个标题如果具有一个或多个标签,那么其下的子项也会继承这些标签.
   #+begin_example
   * Meeting with the French group      :work:
   ** Summary by Frank                  :boss:notes:
   *** TODO Prepare slides for him      :action:
   #+end_example
   在以上示例中,最后一个todo标题虽然只有一个标签,但其实它会继承其父标签,所以该标题含有work,boss,notes,action四个标签
   也可以设置一个标签让所有的标签继承,比如
   #+begin_example
   #+FILETAGS: :Peter:Boss:Secret:
   #+end_example
   这样设置就好像在第0级的标题设置标签一样,所有标题都会继承该标题的标签
***** 标签操作和快捷键
- C-c C-q (org-set-tags-command)
  插入一个标签
- C-c C-c
  与上面功能相同
*** 属性
:PROPERTIES:
:STYLE:    fsd
:END:
