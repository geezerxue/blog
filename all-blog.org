#+hugo_base_dir: ~/workspace/hugoBlog
#+hugo_section: post
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :author "geezer"
#+hugo_code_fence: nil
#+STARTUP: logdrawer

* Blog Ideas
** DONE emacslisp
CLOSED: [2022-11-18 五 22:28]
:PROPERTIES:
:EXPORT_FILE_NAME: emacslisp
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-18 五 22:28]
:END:
*** emacs tutorial
*** emacs init
*** emacs keys
  介绍一些emacs的快捷键,以及如何定义快捷键
**** 定义快捷键
- 定义全局快捷键
  将crtl-b绑定到whitespace-mode上
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-b") 'whitespace-mode)
  #+end_src
- 定义局部快捷键
  局部快捷键只对当前buffer有效,一旦离开当前buffer则会失效
  #+begin_src emacs-lisp
    (local-set-key (kbd "C-b") 'whitespace-mode)
  #+end_src
- 取消某个快捷键
  #+begin_src emacs-lisp
    (global-set-key (kbd "C-b") nil)
  #+end_src
**** 定义快捷键的语法
- 单个修饰键和单个特殊键
  #+begin_src emacs-lisp
    (global-set-key (kbd "M-a") 'backward-char) ; Alt+a
    (global-set-key (kbd "C-a") 'backward-char) ; Ctrl+a
    (global-set-key (kbd "<f3>")  'backward-char) ; F3 key
  #+end_src
- 定义带前缀的快捷键
  当定义某个带前缀的快捷键时需要先取消前缀快捷键的绑定.
  #+begin_src emacs-lisp
    (global-set-key (kbd "<f7>") nil) ; good idea to put nil to the starting key
    (global-set-key (kbd "<f7> <f8>") 'calendar)

    (global-set-key (kbd "C-e") nil) ; good idea to put nil to the starting key
    (global-set-key (kbd "C-e a") 'calendar) ; Ctrl+e a
    (global-set-key (kbd "C-e SPC") 'calendar) ; Ctrl+e Space
  #+end_src
**** 在major-mode中添加快捷键
- 普通方法
   要在某个major-mode上添加快捷键使其只作用于该major-mode,
   其主要原理是在该major-mode上添加hook,使得在开启该major-mode
   后调用我们自定义的函数,而自定义的函数中我们可以定义一个局部快捷键
   这样就可以时的该快捷键只对该major-mode有效
   #+begin_src emacs-lisp
     (when (fboundp 'go-mode)
       (defun my-go-config ()
         "为go-mode添加快捷键"
         (local-set-key (kbd "C-b") 'gocf)
         ;;其他配置)
       (add-hook 'go-mode-hook 'my-go-config))
   #+end_src
- 直接修改mode的键位映射
  如果我们知道某个major-mode的键位映射变量名,则可以直接通过变量名修改
  #+begin_src emacs-lisp
  (progn
  ;; modify dired keys
    (require 'dired )
    (define-key dired-mode-map (kbd "o") 'other-window)
    (define-key dired-mode-map (kbd "2") 'delete-window)
    (define-key dired-mode-map (kbd "3") 'delete-other-windows)
    (define-key dired-mode-map (kbd "4") 'split-window-below)
    (define-key dired-mode-map (kbd "C-o") 'find-file))
  #+end_src
**** 在minor-mode中添加快捷键
   minor-mode的键位映射变量名,一般都是'minor-mode名-mode-map',所以要为某个
   minor-mode添加快捷键可以
   #+begin_src emacs-lisp
  (progn
  ;; change isearch's keys to arrows
  (define-key isearch-mode-map (kbd "<up>") 'isearch-ring-retreat )
  (define-key isearch-mode-map (kbd "<down>") 'isearch-ring-advance )

  (define-key isearch-mode-map (kbd "<left>") 'isearch-repeat-backward)
  (define-key isearch-mode-map (kbd "<right>") 'isearch-repeat-forward)
  )
   #+end_src
**** minor-mode的快捷键优先级
   minor-mode的快捷键优先级存放在 *minor-mode-map-alist*
   它是一个关联列表,可通过修改该变量来修改minor-mode优先级
**** 定义快捷键前缀
#+begin_src elisp
  ;;定义快捷键前缀命令
  (define-prefix-command 'geezer-prefix)
  ;;将以上命令绑定到某个快捷键上
  (global-set-keys (kbd "C-z") 'geezer-prefix)
  ;;经过以上两步就可以是的'C-z'成为一个前缀按键
  ;;之后只需要在该前缀按键添加即可
  (define-key my-keymap (kbd "<f6>") 'visual-line-mode)
#+end_src
**** 同一个命令在不同major-mode的不同作用
   要是同一个命令在不同major-mode中的作用不同,最简单的方法就是封装该命令,
   再在命令中判断当前major-mode
   假设我们在x1-mode时执行该命令会调用x1-cmd
   在x2-mode时,为x2-cmd
   #+begin_src elisp
     ;;定义x1-cmd函数和x2-cmd函数
     (defun x1-cmd () ())
     (defun x2-cmd () ())

     (defun geezer-smart-cmd ()
       (interactive)
       (cond
        ((string-equal major-mode "x1-mode") (x1-cmd))
        ((string-equal major-mode "x2-mode") (x2-cmd))
        (t nil)
       ))
   #+end_src
**** 定义可临时重复使用的快捷键
   在emacs有这样的操作,调用某个命令后就可以重复按住指定键来重复执行该命令,而且这个操作
   是可以中断的,中断后之前的按键就会失效.这就好比在浏览器中我们可以按住ctrl键,然后滚动
   鼠标就能实现放大缩小,而松开ctrl键后就没有这种效果了.
   在emacs也有这样的操作,比如 *text-scale-adjust* 调用该命令后,允许按 *+* 键放大,按 *-*
   键缩小等操作,而结束该命令后就会失去该效果
   下面我们来实现下这个操作
   #+begin_src elisp
     (defun geezer-forward-word ()
       "移动光标"
       (interactive)
       (progn
         (forward-char)
         (set-transient-map
          (let (($kmap (make-sparse-keymap)))
            (define-key $kmap (kbd "r") 'geezer-forward-word)
            (define-key $kmap (kbd "l") 'geezer-backward-word)
            $kmap
            )
          )
         )
       )
     (defun geezer-backward-word ()
       "移动光标"
       (interactive)
       (progn
         (forward-char)
         (set-transient-map
          (let (($kmap (make-sparse-keymap)))
            (define-key $kmap (kbd "r") 'geezer-forward-word)
            (define-key $kmap (kbd "l") 'geezer-backward-word)
            $kmap
            )
          )
         )
       )
   #+end_src
   以上代码中 *set-transient-map* 接受一个keymap,并且使用该keymap一次,并且该keymap的
   优先级会高于其他的minor-mode
   而let中的代码,则返回一个 keymap,使用该keymap后按r或者l都会执行一个递归函数
   以此实现重复调用,这样在调用该函数后,可以重复使用r和l实现对应的操作.按C-g可结束
   也可以自定义一个键位结束,结束后r和l的功能会还原,
**** 在emacs中输入表情,及其他unicode符号
   *key-translation-map* 是emacs自带的一个keymap,在任何buffer都有效
   所以我们可以向里面添加map实现输入表情的效果
   #+begin_src elisp
     (define-key key-translation-map (kbd "<f8>") (kbd "•"))
          ;; set keys to insert math symbol
     (define-key key-translation-map (kbd "<f9> p") (kbd "φ"))
     (define-key key-translation-map (kbd "<f9> x") (kbd "ξ"))
     (define-key key-translation-map (kbd "<f9> i") (kbd "∞"))
     (define-key key-translation-map (kbd "<f9> <right>") (kbd "→"))

     ;; set keys to insert emoji
     (define-key key-translation-map (kbd "<f9> 1") (kbd "😅"))
     (define-key key-translation-map (kbd "<f9> 2") (kbd "❤"))
   #+end_src
   这里不推荐使用 *global-set-key* 的方式,就像下面这种
   #+begin_src elisp
     (global-set-key (kbd "<f8>") (lambda () (interactive) (insert "→")))
   #+end_src
   这种方法的确可行,但在使用isearch时会失效
**** 交换键盘按键
交换f11和f12
#+begin_src emacs-lisp
    (define-key key-translation-map (kbd "<f11>") (kbd "<f12>"))
    (define-key key-translation-map (kbd "<f12>") (kbd "<f11>"))
#+end_src
**** 鼠标操作
- 取消鼠标的加速
  #+begin_src elisp
    (setq mouse-wheel-progressive-speed nil)
  #+end_src
- 控制鼠标每次移动的行数
  是鼠标每次能够移动两行
  #+begin_src elisp
    (setq mouse-wheel-scroll-amount '(2))
  #+end_src
- 取消鼠标高亮
  #+begin_src elisp
    (setq mouse-highlight nil)
  #+end_src
***** 鼠标的语法
| 鼠标按键              | elisp表示            |
|-----------------------+----------------------|
| 鼠标左键              | (kbd "<mouse-1>")    |
| 鼠标滚轮键            | (kbd "<mouse-2>")    |
| 鼠标右键              | (kbd "<mouse-3>")    |
| 鼠标滚轮向前(linux)   | (kbd "<mouse-4>")    |
| 鼠标滚轮向后(linux)   | (kbd "<mouse-5>")    |
| 鼠标滚轮向前(mac,win) | (kbd "<wheel-up>")   |
| 鼠标滚轮向后(mac,win) | (kbd "<wheel-down>") |
*** lisp basics
**** 基础
- 输出函数print
  格式:(print OBJECT &optional PRINTCHARFUN)
  print接受一个输出对象和一个输出的目标buffer
  object即为输出对象,printcharfun即输出的目标buffer
  #+begin_src elisp
  (progn
    (setq gbuffer (generate-new-buffer "*my output*"))
    (print "fasdfs" gbuffer)
    (switch-to-buffer gbuffer))
  #+end_src
- unicode字符表示
  *\uxxxx* :接受四个16进制数
  *\u00xxxxxx* :接受六个16进制数
- 处理字符串的函数
  | 函数             | 示例                            | 作用                        | 结果               |
  |------------------+---------------------------------+-----------------------------+--------------------|
  | length           | (length "abc")                  | 获得"abc"长度               | 3                  |
  | substring        | (substring "abc123" 0 3)        | 截取字符串0-3之间的子字符串 | abc                |
  | concat           | (concat "some" "thing")         | 字符串拼接                  | something          |
  | split-string     | (split-string "xy_007_cat" "_") | 以'_'截取字符串             | ("xy","007","cat") |
  | string-to-number |                                 | 字符串转数字                |                    |
  | number-to-string |                                 | 数字转字符                  |                    |
- 相等判断
  equal:判断数据类型和值是否相同
  eq:判断是否为同一对象
  eql:与eq很像但两个相同的浮点数会返回t
**** 数据类型
- mapcar
  (mapcar FUNCTION SEQUENCE)
  会返回处理后的结果
- mapc
  与mapcar一样但不会返回结果,而返回nil

*** practical emacs lisp
**** 概述
***** 光标位置
| 函数                    | 作用                                               |
|-------------------------+----------------------------------------------------|
| point                   | 返回当前光标位置,其值为前面字符个数,包括空格和回车 |
| region-beginning        | 返回选中区域的开头字符位置                         |
| region-end              | 返回选中区域的结尾字符位置                         |
| line-beginning-position | 返回行首字符位置                                   |
| line-end-position       | 返回行为字符位置                                   |
| point-min               | 返回整个文件开头位置                               |
| point-max               | 返回整个文件结尾位置                               |
***** 光标移动和文本搜索
#+begin_src emacs-lisp
  ;;跳转到39字符的位置
   (goto-char 39)
  ;;使光标前移和后移四个字符
  (forward-char 4)
  (backward-char 4)
  ;;向前搜"some"和向后搜索"some"
  (search-forward "some") ; to end of “some”
  (search-backward "some") ; to beginning of “some”
  ;;向前搜索数字和向后搜索数字
  (re-search-forward "[0-9]") ; digit
  (re-search-backward "[0-9]")
  ;;将光标前移和将光标后移,知道找到非小写字母
  (skip-chars-forward "a-z")
  (skip-chars-backward "a-z")
#+end_src
***** 修改文本
#+begin_src emacs-lisp
  ;;从光标开始删除9个字符
  (delete-char 9)
  ;;删除3-10位置的字符
  (delete-region 3 10)
  ;;在当前光标处插入字符串
  (insert "i ♥ cats")
  ;;获取当前buffer71-300的字符串,并赋值给x
  (setq x (buffer-substring 71 300))

  ;;将7-300处的字母转为大写
  (capitalize-region 71 300)
#+end_src
***** buffer操作
#+begin_src emacs-lisp
  ;;获取buffer名称
  (buffer-name)

  ;;返回当前buffer文件的绝对路径
  (buffer-file-name)

  ;; switch to the buffer named xyz
  (switch-to-buffer "xyz")

  ;;保存当前buffer
  (save-buffer)

  ;; 关闭名为"xyz"的buffer
  (kill-buffer "xyz")

  ;;临时将"xyz"buffer作为当前buffer,函数结束后将返回之前操作的buffer
  (with-current-buffer "practical-elisp.el"
    ;;这里可以写一些插入删除等操作
  )
#+end_src
***** 文件操作
- 基本操作
  #+begin_src emacs-lisp
    ;; open a file (in a buffer)
  (find-file "~/")

  ;; same as “Save As”.
  (write-file path)

  ;; insert file into current position
  (insert-file-contents path)

  ;; append a text block to file
  (append-to-file start-pos end-pos path)

  ;; renaming file
  (rename-file file-name new-name)

  ;; copying file
  (copy-file old-name new-name)

  ;; deleting file
  (delete-file file-name)

  ;; get dir path
  (file-name-directory  full-path)

  ;; get filename part
  (file-name-nondirectory full-path)

  ;; get filename's suffix
  (file-name-extension file-name)

  ;; get filename sans suffix
  (file-name-sans-extension file-name)
  #+end_src
- narrow操作
  narrow操作可以使文件只有指定的部分可见,而其余部分不可见,除此以外它的效果与
  删除效果几乎相同,它会对光标行数等产生影响.可以调用"widen"把刚才隐藏的部分显示出来
  | 函数             | 作用                                      |
  |------------------+-------------------------------------------|
  | narrow-to-defun  | 仅显示当前光标所在的函数                  |
  | narrow-to-page   | 仅显示当前页面中可见的内容                |
  | narrow-to-region | 仅显示指定位置的内容                      |
  | widen            | 显示隐藏部分的内容                        |
  | buffer-narrow-p  | 判断当前buffer是否有隐藏内容              |
  | save-excursion   | 保存当前光标位置,执行完body里的内容后返回 |
  | save-restriction | 保存当前缓冲区,执行完body里的内容后返回通常与narrow一起使用    |
***** 案例
- 替换选中区域的文本
  #+begin_src emacs-lisp
 (defun geezer-replace-greek-region ()
  (interactive)
  (let ((start (region-beginning))
        (end (region-end)))
    (save-restriction
      (narrow-to-region start end)
      (goto-char (point-min))
      (while (search-forward "a" nil t)
        (replace-match "A" nil t))
      (goto-char (point-min))
      (while (search-forward "b" nil t)
        (replace-match "B" nil t)))))
  #+end_src
- 删除括号中的内容
  #+begin_src emacs-lisp
 (defun geezer-delete-pair ()
  (interactive)
  (save-excursion
    (let (p1 p2)
      (skip-chars-backward "^([{<>")
      (setq p1 (point))
      (skip-chars-forward "^)]}<>")
      (setq p2 (point))
      (delete-region p1 p2))))
  #+end_src
***** defun中的interactive的作用
定义函数时interactive的作用有两个
1. 是函数可以以命令的形式调用,及通过M-x的方式
2. 在interactive后加上参数可以是调用该函数时实现交互式传参
****** 参数说明
- (ineractive)
  可以用命令调用
- (ineractive string)
  string第一个字符指定输入的内容,例如为s则表示为输入一个字符串,为n则表示数字等,
  若要从交互界面获取多个参数可以用回车隔开
  #+begin_src emacs-lisp
    (defun ask-name-and-age (x y)
  "Ask name and age"
  (interactive
   "sEnter name
    nEnter age:")
  (message "Name is: %s, Age is: %d" x y))
  #+end_src
- (ineractive list)
  这种方式是最常用的一种方式,list中可以是任何表达式,只要能够返回对应参数个数的list即可
  #+begin_src emacs-lisp
      (defun ask-name-and-age2 (x y)
    "Ask name and age"
    (interactive
     (list
      (read-string "Enter
    name:")
      (read-number "Enter age:")))
    (message "Name is: %s, Age is: %d" x y))
  #+end_src
****** thing-at-point
函数调用:(thing-at-point THING &optional NO-PROPERTIES)
当我们用interactive进行交互时,使用 *thing-at-point* 是非常方便的,
例如,我们在寻求帮助时,使用的describe-function,describe-variable(对应快捷键C-h f,C-h k)时,
就会获取当前光标处的函数或变量,使得我们在调用上面两个命令时,如果我们不做输入,它会默认选择光标处的函数或变量
thing-at-point不仅可以获取当前光标处的函数和变量,同时也可以获取光标处的
'symbol, 'list, 'sexp, 'defun, 'filename, 'url, 'email, 'uuid, 'word, 'sentence, 'whitespace, 'line, 'number, 'page.
只需要将 *thing-at-point* 的第二个参数设为上面这些值即可
#+begin_src emacs-lisp
  (defun test ()
    "获取单词"
    (interactive)
    (message "%s" (thing-at-point 'word)))
#+end_src
****** bounds-of-thing-at-point
获取thing-at-point的边界,返回的是一个cons,其第一个元素为边界的开始的位置,第二个元素为边界结束的位置
#+begin_src emacs-lisp
  (defun test ()
    (interactive)
    (let (bounds pos1 pos2 mything)
      (setq bounds (bounds-of-thing-at-point 'symbol))
      (setq pos1 (car bounds))
      (setq pos2 (cdr bounds))
      (setq mything (buffer-substring-no-properties pos1 pos2))
      (message
       "thing begin at [%s],end at [%s],thing is [%s]"
       pos1 pos2 mything))
#+end_src
***** 查找替换
- search-forward和search-backward.
  (search-forward STRING &optional BOUND NOERROR COUNT)
  将关闭移动到要查找的字符串开始位置,
- re-search-forward和re-search-backward
  (re-search-forward REGEXP &optional BOUND NOERROR COUNT)
  与上面函数功能一样,不过匹配的是正则表达式,而非字符串
- search-forward-regexp和search-backward-regexp
  分别是re-search-forward和re-search-backward的别名
- case-fold-search变量
  其值默认为t,表示查找是忽略大小写
  为nil时,表示不忽略大小写
**** elisp脚本
***** 运行elisp脚本
elisp可以运行在终端,比如
#+begin_src shell
  emacs --script  /path/to/elisp-file
#+end_src

***** buffer相关函数
- buffer-name
  (buffer-name &optional BUFFER)
  获取当前buffer名字
- buffer-file-name
  (buffer-file-name &optional BUFFER)
  返回当前buffer处文件的绝对路径,如果不存在则返回nil
- with-current-buffer
  (with-current-buffer BUFFER-OR-NAME &rest BODY)
  将某个缓冲区作为临时的缓冲区,执行完body里的内容后返回
- set-buffer
  (set-buffer BUFFER-OR-NAME)
  跳转到指定buffer,但该buffer不可见,如果需要可见可使用switch-to-buffer
- generate-new-buffer
  (generate-new-buffer NAME)
  新建一个buffer
- get-buffer-create
  (get-buffer-create BUFFER-OR-NAME)
  新建一个buffer,但不将其作为当前buffer
- kill-buffer
  (kill-buffer &optional BUFFER-OR-NAME)
  关闭指定buffer
***** 文件相关函数
- directory-files
  返回一个带有该目录下所有指定文件的list
  不会递归查找,即如果该目录下有子目录不会对子目录进行查找
  (directory-files DIRECTORY &optional FULL MATCH NOSORT)
  参数1:目录路径
  参数2:返回的文件是否为绝对路径
  参数3:文件匹配的方式
  参数4:是否排序
- directory-files-recursively
  递归查找指定文件,后返回一个带有所有指定文件的list
  会递归查找,即如果该目录下有子目录会对子目录进行查找
  由于会递归查找所以会返回文件的相对路近,而非只含文件名
  (directory-files-recursively DIR REGEXP &optional INCLUDE-DIRECTORIES)

*** elisp example
*** emacs write major-mode
**** font lock mode
它是emacs内置的一个minor-mode,它与当前buffer的语法高亮有关,其高亮规则通过两种方式实现
1. Syntactic fontification
   一些与注释字符串,符号相关的注释,它的注释内容存放在,Syntax Table中,可通过describe-syntax命令查看
2. Search based fontification
   使用正则表达式查找相关内容进行高亮,通常高亮的是一些关键字,函数名,变量名之类的,它依赖于,font-lock-defaults变量
**** font-lock-defaults
该变量通常是一个list,为nil的话将不会进行任何高亮,而list里面通常有四个关键变量
1. font-lock-keywords
   关键字的高亮规则
2. font-lock-keywords-only
   字符串和注释等的高亮规则
3. font-lock-keywords-case-fold-search
   正则表达式是否区分大小写
4. font-lock-syntax-table
   与syntax有关
** DONE orgmode
CLOSED: [2022-11-18 五 22:28]
:PROPERTIES:
:EXPORT_FILE_NAME: orgmode
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-18 五 22:28]
:END:
*** 文档结构
**** 列表
   * 无序列表
     + 使用"*"号的列表
       由于org中*号可以有两种含义,即标题和列表.所以若要用*号表示列表的话,*号不能位于行首否则就成标题了.
       示例:
       * 列表1
       * 列表2
       * 列表3
     + 使用"+"号或"-"号的列表
       与*号用法基本一致,唯一不同的是可以位于行首
   * 有序列表
     有序列表使用"1."或者"1)"开头
     示例:
     1. 第一
        1) fsdaf
        2) fdsja
     2. 第二
     3. 第三
   * 结束列表
     可以在列表下空两行,结束该列表,或者将内容的缩进修改成小于或等于该列表也可以结束列表.
   * 常用操作与快捷键
     * <tab>
       对列表进行收缩或展开
     * M-RET
       在该列表下方新建一个与该列表同级的列表.
       注意:如果光标位于列表名称的中将的话,则会将该列表后的内容作为新列表.
     * M-S-RET
       在该列表下方新建一个与该列表同级并且带有复选框的列表.其他与M-RET功能相似.
     * S-UP和S-DOWN
     * M-UP和M-DOWN
       移动列表,将列表上移或者下移.移动时会连其下的内容也会随之移动.
     * M-LEFT和M-RIGHT
       提升或者降低列表的级别.不会连同子列表一起移动.
     * M-S-LEFT和M-S-RIGHT
       提升或者降低列表的级别.会连同子列表一起移动
     * C-c C-c
       与复选框相关的操作
     * C-c -
       修改与当前列表同级的表示方式,使它们的表示方式在"-,+,*,1.,1)"中循环切换.如果有选中区域的话则只对该区域内的列表有效.
     * C-c *
       将当前列表修改为标题,使其下与其同级别的列表成为它的子项
     * C-c C-*
       将当前列表级别一致的列表修改为缩进一致的标题.
     * S-LEFT和S-RIGHT
       修改列表与当前列表同级别的表示方式,在"-,+,*,1.,1)"切换.
       注意:使用此操作是需要将光标移动到表示列表的符号上.
     * C-c ^
       对列表进行排序,可以按数字,字母,时间或者自定义函数进行排序.

**** drawer
+ 简介
  drawer里可以保存一些与内容相关的东西,而你又不希望显示他们,就可以使用drawer,这个有点类似于标签的功能.
+ 示例
  :drawer的名称:
  drawer的内容
  :END:
+ 常用操作与快捷键
  * 插入一个drawer
    C-c C-x d
  * 插入一个带有时间的drawer
    C-c C-z

**** block
   - 简介
     block通常用于存放代码块和一些示例,以"#+BEGIN"开头,中间写入内容,以"#+END"结尾.
   - 示例
     + 引用块
       #+BEGIN_QUOTE
        引用内容
       #+END_QUOTE
     + 示例块
       #+Begin_EXAMPLE
        示例
       #+END_EXAMPLE
     + 代码块
       #+begin_src c
         int main()
           {
             int a=;
             float d=0;
             return 0;
             }
       #+end_src
*** 表格
**** 创建表格
- 表格表示
  如果某行是以'|'开头并且非空的花一般会被视为是一个表格,而以'|-'开头则会被视为是一个表格的水平线.
- 示例:
   |   | 1 | 2 | 3 |
   |---+---+---+---|
   | 1 |   |   |   |
   | 2 |   |   |   |
   | 3 |   |   |   |
- 快捷键
  * <tab>
    1. 输入"|"时如果是首字母,按tab会自动生成表格
    2. 输入"|-"时如果是首字母,按tab会自动生成表格的水平线
    3. 当光标在表格中输入tab会将往右移至下一个表格,如果表格已经是最后一个则会移动下一行第一个,如果下一行没有内容则会先在下一行新建一列.
  * S-<tab>
    与<tab>相反,不过只包含移动操作.
  * M-a
    将光标定位的当前格子的最前面,如果光标所在格子没有内容者与<tab>功能相同
  * M-a
    将光标定位的当前格子的最后,如果光标所在格子没有内容者与S-<tab>功能相同
  * RET
    上下移动表格,如果表格已经是最后一行则会在下一行新建一行比表格后载移动下一行第一个
  * C-c | (org-table-create-or-convert-from-region)
    该命令输入后会提示用户输入表格的列x行,输入后会在该区域创建一个这样的表格.如果当前选中的区域是以逗号或者空格分开的,则该命令会按此自动生成表格.
  * C-c C-c
    是当前表格对齐
  * org-table-blank-field
    清空当前光标所处位置的格子中的内容
  * M-LEFT (org-table-move-column-left)和M-RIGHT (org-table-move-column-right)
    将当前列向指定方向移动
  * M-S-LEFT (org-table-delete-column)
    将当前列删除
  * M-S-RIGHT (org-table-insert-column)
    在当前列的前面新建一列
  * M-UP (org-table-move-row-up)和M-DOWN (org-table-move-row-down)
    将当前行向指定方向移动.
  * M-S-UP (org-table-kill-row)
    将当前行删除
  * M-S-DOWN (org-table-insert-row)
    在当前行上面新建一行.
  * 对单个格子移动
    - S-UP (org-table-move-cell-up)
      将当前格子向上移动
    - S-DOWN (org-table-move-cell-down)
      将当前格子向下移动
    - S-LEFT (org-table-move-cell-left)
      将当前格子向左移动
    - S-RIGHT (org-table-move-cell-right)
      将当前格子向右移动
  * C-c - (org-table-insert-hline)
    在当前行下面插入表格的水平线
  * C-c RET (org-table-hline-and-move)
    与C-c -功能一致,不过会移动至新建的水平线下一行表格
  * C-c ^ (org-table-sort-lines)
    对表格进行排序,排序的选择对象为光标所在的列.
  * C-c ` (org-table-edit-field)
    新开一个buffer对当前格子的内容进行编辑
  * M-x org-table-transpose-table-at-point
    将光标所在的表格进行行列互换
  * C-c TAB (org-table-toggle-column-width)
    收缩或者扩张
*** 超链接
**** 创建超链接
   示例:
   #+begin_example
   [[链接][描述]]
   或
   [[链接]]
   #+END_example

**** 链接类型
   - 内部链接
     + 使用id
       跳转到指定id位置
       #+begin_example
       [#custom_id]
       #+end_example
     + 使用章节
       跳转到指定章节
       #+begin_example
       [*section]
       或
       [section]
       #+end_example
     + 定义标记
       跳转到自定义的标记,使用'<<target>>'自定义一个标记
       #+begin_example
       <<target>>
       [target]
       #+end_example
   - 外部链接
     可以打开网址,文件等内容,一般都有自己的格式开头,比如网址以http或https开头,文件以file开头
     #+begin_example
     [[https://www.baidu.com]]
     [[file:/home/cl/]]
     #+end_example

*** todo-item
**** todo的使用
   todo跟标题的使用方式几乎一样,在标题前加上TODO(大写)即可是标题成为一个TODO列表
   #+begin_example
   *** TODO 开会
   #+end_example
***** 常用的快捷键和命令
| 快捷键          | 命令                    | 作用                                                             |
|-----------------+-------------------------+------------------------------------------------------------------|
| C-c C-t         | org-todo                | 切换todo的状态                                                   |
| S-right和S-left |                         | 循环切换todo状态                                                 |
| C-c / t         | org-show-todo-tree      | 将文档中所以的todo项以稀疏树的形式展现出来                       |
| C-c a t         | org-adenda t            | 显示全局 TODO 列表。从所有的议程文件中收集 TODO 项到一个缓冲区中 |
| S-M-RET         | org-insert-todo-heading | 插入一个todo列表                                                 |

**** 完成进度
   可以在标题或者todo列表后加上'[/]'或者'[%]'来其子项todo的完成进度或者复选框的选择比例,按'C-c C-c'可以刷新其状态
***** 示例  [2/4] [50%]
****** DONE 111
CLOSED: [2022-10-29 六 11:40]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-10-29 六 11:40]
:END:
****** TODO 222
****** TODO 333
****** DONE 444
CLOSED: [2022-10-29 六 11:41]
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-10-29 六 11:41]
:END:
**** 复选框
   复选框是特殊的列表,在列表的名称前加上'[ ]'即是一个复选框
   例如:
***** TODO today arrange [0/3] [0%]
:PROPERTIES:
:ORDERED:  t
:END:
    - [-] call someone [1/3]
      - [ ] peter
      - [ ] lasy
      - [X] jonh
    - [-] order food [2/3]
      - [X] milk
      - [ ] bread
      - [X] dumpling
    - [-] listen music [33%]
      - [ ] jay chou
      - [X] justin biber
      - [ ] mike jackson
***** 操作与快捷键
    - C-c C-c和C-c C-x C-b(org-toggle-checkbox)
      触发复选框的状态
    - C-c C-x C-r (org-toggle-radio-button)
      是得同级的复选框只能选中一个或不选,执行此命令会是同级复选框都处于非选中状态,如果当前复选框是选中的则取消选中,否则选中.
    - M-S-RET (org-insert-todo-heading)
      插入一个新的复选框
*** 标签
  标签是对标题的说明,可以在标题后使用并且一个标题可以含有多个标签,标签的前后都必须有一个冒号
**** 标签的继承
   标签具有继承性,一个标题如果具有一个或多个标签,那么其下的子项也会继承这些标签.
   #+begin_example
   * Meeting with the French group      :work:
   ** Summary by Frank                  :boss:notes:
   *** TODO Prepare slides for him      :action:
   #+end_example
   在以上示例中,最后一个todo标题虽然只有一个标签,但其实它会继承其父标签,所以该标题含有work,boss,notes,action四个标签
   也可以设置一个标签让所有的标签继承,比如
   #+begin_example
   #+FILETAGS: :Peter:Boss:Secret:
   #+end_example
   这样设置就好像在第0级的标题设置标签一样,所有标题都会继承该标题的标签
***** 标签操作和快捷键
- C-c C-q (org-set-tags-command)
  插入一个标签
- C-c C-c
  与上面功能相同
*** 属性
:PROPERTIES:
:STYLE:    fsd
:END:
** DONE shell编程
CLOSED: [2022-11-25 五 23:34]
:PROPERTIES:
:EXPORT_FILE_NAME: shell编程
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-25 五 23:34]
:END:
*** 基本bash shell命令
1. more命令
   用于浏览文件,实现了基本的翻页功能
2. less命令
   可以理解为more的升级版,但实际上与more命令相差不大
3. tail命令
   查看文件尾部的几行内容
4. head命令
   与tail命令相反
*** 更多bash shell命令
**** 进程相关命令
1. ps命令
   Linux系统中使用的GNU ps命令支持3种不同类型的命令行参数：
     Unix风格的参数，前面加单破折线(-)
     BSD风格的参数，前面不加破折线
     GNU风格长参数,前面加双破折号(--)
   * unix风格的参数
      | 参数 | 功能                                                   |
      |------+--------------------------------------------------------|
      | -A   | 显示所有进程                                           |
      | -N   | 显示与指定参数不符的所有进程                           |
      | -a   | 显示除控制进（session leader）和无终端进程外的所有进程 |
      | -d   | 显示除控制进程外的所有进程                             |
      | -e   | 显示所有进程                                           |
      | -C   | cmdlist显示包含在cmdlist列表中的进程                   |
      | -G   | grplist显示组ID在grplist列表中的进程                   |
      | -U   | userlist显示属主的用户ID在userlist列表中的进程         |
      | -s   | sesslist                                               |
      | -t   | ttylist显示终端ID在ttylist列表中的进程                 |
      | -u   | userlist显示有效用户ID在userlist列表中的进程           |
      | -F   | 显示更多额外输出（相对-f参数而言）                     |
      | -O   | format显示默认的输出列以及format列表指定的特定列       |
      | -M   | 显示进程的安全信息                                     |
      | -c   | 显示进程的额外调度器信息                               |
      | -f   | 显示完整格式的输出                                     |
      | -j   | 显示任务信息                                           |
      | -l   | 显示长列表                                             |
      | -o   | format仅显示由format指定的列                           |
      | -y   | 不要显示进程标记（processflag，表明进程状态的标记）    |
      | -Z   | 显示安全标签（security context）①信息                 |
      | -H   | 用层级格式来显示进程（树状，用来显示父进程）           |
      | -n   | namelist定义了WCHAN列显示的值                          |
      | -w   | 采用宽输出模式，不限宽度显示                           |
      | -L   | 显示进程中的线程                                       |
      | -V   | 显示ps命令的版本号                                     |
2. kill命令
**** 文件相关命令
***** grep基本使用
****** 反向搜索
查找没有字母"t"的行
grep -v t filename
****** 显示查找内容的行号
查找t所在的行并显示行号
grep -n t filename
****** 统计搜索结果的行数
统计搜索结果中含有字母"t"的行数
grep -c t filename
****** 使用多种搜索模式
查找含"t"或含"f"的行
grep -e t -e f filename
*** linux文件管理系统
**** linux基本文件系统
***** ext
*** 构建基本脚本
**** 创建shell脚本文件
在shell脚本文件中用'#'表示注释,但第一行却是个例外,一般shell的第一行为
#+begin_src shell
#!/bin/bash
#+end_src
这一行告诉shell用哪个shell来运行脚本,当然这里的bash只是一个示例,你也可以用其他的shell.
除第一行外,其他行若以'#'开头则只起注释作用不做任何解释.
**** 变量
在shell中若要使用变量则需要在变量名前加'$'才可以被解释为一个变量,
否则会被解释为普通字符串,若要输出'$'则可以使用'\$'
在shell中变量命名的规则为字母,数字,下划线且长度不能超20个字符,变量
名是区分大小写的.
- 变量创建
  变量创建只需使用变量名后加'='即可
  赋值也与变量创建方法相同
  注意:
  若要将一个变量赋值给其他变量,则必须要有'$',否则会被解释为字符串
  变量名和'='以及值之间不能有空格
  #+begin_src shell
    value1=fsdfd
    value2=$value1
  #+end_src
**** 命令替换
通常来说,若想获得一条命令的输出,可使用反引号'`'或者'$()',
#+begin_src shell
  val=$(echo  3) 或者 val=`ehco 3`
   echo $val
#+end_src
上面示例中'val'的只会等于'ehco 3'的值即为3
**** 重定向输入输出
- 输出重定向
  其基本功能是将命令的输出写到指定文件中,
  * 格式:
    ls(仅做示范,使用其他命令均可) > 文件名
    ls >> 文件名
  符号'>'表示覆盖文件
  符号'>>'表追加
- 输入重定向
  输入重定向和输出重定向正好相反。输入重定向将文件的内容重定向到命令.
  * 格式:
    wc < 文件名
  wc是一个统计文本的命令,它会计算出文本的行数,词数,及字节数
  上面示例的含义即为统计文件的行数,词数,字节数
  * 格式2
    wc << 标记
  这种格式成为内联输入重定向,它的使用需要一个标记,作为文本的结尾标记
  * 例如
    $ wc << EOF
    > test string 1
    > test string 2
    > test string 3
    > EOF
**** 管道
其含义是将一个命令的输出作为另一个命令的输入,
利用重定向的方式可表示为:
#+begin_example
ls  -U  >  temp
sort  <  temp
#+end_example
示例含义为将ls的不排序的输出结构写到temp文件,在用sort对temp文件排序输出\
但linux提供了更简便的方式
即我们可以利用'|'符号:
#+begin_example
ls -U  | sort
#+end_example
这命令与上面的功能相同,并且还不需要中间文件
**** 使用数学表达式
若要在shell中使用数学表达式则需要使用关键字'expr 表达式'或则使用'$[表达式]'
- 示例
  #+begin_example
expr  4 / 2
$[4 / 2]
  #+end_example
上面描述的两种数学表达式的使用都不支持浮点数运算
解决此问题最常用的是使用bash计算器bc,它能够识别数字,变量,注释,表达式,编程语句,函数
而bc中存在内置变量scale它可以控制浮点数输出的位数,若为它赋值则默认为0,即不保留小数位
利用其那面学的管道,我们就可以实现在shell脚本中使用bc
#+begin_example
var1=$(echo  "scale=4;10/3" |   bc)
#+end_example
但如果是比较长的计算使用这种方法非常的麻烦,
所以我们可以使用前面所学的内联重定向输入'<<'
#+begin_src shell
var1=10.46
var2=43.67
var3=33.2
var4=71
var5=$(bc << EOF
scale = 4
a1 = ( $var1 * $var2)
b1 = ($var3 * $var4)
a1 + b1
EOF
)
#+end_src
**** 退出脚本
- 退出码
  Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。
  | 状态码 | 描述                             |
  |--------+----------------------------------|
  |      0 | 命令成功结束                     |
  |      1 | 一般性未知错误                   |
  |      2 | 不适合的shell命令                |
  |    126 | 命令不可执行(一般为没有执行权限) |
  |    127 | 没找到命令                       |
  |    128 | 无效的退出参数                   |
  |  128+x | 与Linux信号x相关的严重错误       |
  |    130 | 通过Ctrl+C终止的命令             |
  |    255 | 正常范围之外的退出状态码         |
- exit命令
  exit命令在脚本中可用于返回自己定义的退出码,一般来说shell脚本会返回最后一个命令
  执行所返回的退出码,而使用exit可以自己返回一个自定义的退出码
  #+begin_example
命令开始
.
.
.
命令结束
exit 8
  #+end_example
  使用示例中的代码就可以实现返回自定义的退出码,示例中返回的是8
*** 使用结构化命令
**** if使用
if后可以接受一个命令,if会根据命令的退出码来判断执行的分支,
退出码为0即命令正确执行,则执行then后的命令集,否则不执行或执行其他分支
基本使用方式如下
#+begin_src shell
   #!/bin/bash

   #形式1
   if 命令
   then
   ...
   fi

   #形式2
   if 命令
   then
  ...
   else
   ...
   fi
   #形式3
   if 命令
   then
   ...
   elif
   then
   ...
   else
   ...
   fi
#+end_src
**** test命令
由于if语句后面只能通过命令的退出码来判定执行分支,使得if使用很不方便
test命令就可以实现类似于其他编程语言的if判断规则,它的工作原理是但test命令中
所执行的条件如果为真则返回状态码0,使得then可以执行,否则返回非0状态码,执行其他分支
其基本能形式为:
#+begin_src shell
  if test 条件
then
  ...
  fi
#+end_src
也可以在if后面加'[条件]'来判断,这与test的功能是一样的
#+begin_src shell
if  [条件]
then
...
fi
#+end_src
- test数值比较
  | 比较        | 描述                   |
  |-------------+------------------------|
  | n1  -eq  n2 | 检查n1是否与n2相等     |
  | n1  -ge n2  | 检查n1是否大于或等于n2 |
  | n1 -gt n2   | 检查n1是否大于n2       |
  | n1 -le n2   | 检查n1是否小于或等于n2 |
  | n1 -lt  n2  | 检查n1是否小于n2       |
  | n1 -ne  n2  | 检查n1是否不等于n2     |
- test字符串比较
  | 比较         | 描述                   |
  |--------------+------------------------|
  | str1 = str2  | 检查str1是否和str2相同 |
  | str1 != str2 | 检查str1是否和str2不同 |
  | str1 < str2  | 检查str1是否比str2小   |
  | str1 > str2  | 检查str1是否比str2大   |
  | -n str1      | 检查str1的长度是否非0  |
  | -z str1      | 检查str1的长度是否为0  |
- test文件比较
  | 比较            | 描述                                     |
  |-----------------+------------------------------------------|
  | -d file         | 检查file是否存在并是一个目录             |
  | -e file         | 检查file是否存在                         |
  | -f file         | 检查file是否存在并是一个文件             |
  | -r file         | 检查file是否存在并可读                   |
  | -s file         | 检查file是否存在并非空                   |
  | -d file         | 检测file是否是一个目录                   |
  | -w filed        | 检查file是否存在并可写                   |
  | -x file         | 检查file是否存在并可执行                 |
  | -O file         | 检查file是否存在并属当前用户所有         |
  | -G file         | 检查file是否存在并且默认组与当前用户相同 |
  | file1 -nt file2 | 检查file1是否比file2新                   |
  | file1 -ot file2 | 检查file1是否比file2旧                   |
- test逻辑运算
  | 选项                       | 描述                                                                     |
  |----------------------------+--------------------------------------------------------------------------|
  | expression1 -a expression  | 逻辑与，表达式 expression1 和 expression2 都成立，最终的结果才是成立的。 |
  | expression1 -o expression2 | 逻辑或，表达式 expression1 和 expression2 有一个成立，最终的结果就成立。 |
  | !expression                | 逻辑非，对 expression 进行取反。                                                                         |
**** 复合条件测试
if语句支持使用布尔值进行复合测试
#+begin_example
if  [ condition1 ] && [ condition2 ]
then
...
fi


if  [ condition1 ] || [ condition2 ]
then
...
fi
#+end_example
**** if高级特征
- 使用双括号
  双括号可以理解为是test数值检测的升级版,在双括号内不仅可以使用test的数值检测
  能使用的表达式
  还能使用一些其他常用的运算符
  | 符号   | 功能     |
  |--------+----------|
  | val++  | 后增     |
  | val--  | 后减     |
  | ++val  | 先增     |
  | --val  | 先减     |
  | !      | 逻辑求反 |
  | ~      | 位求反   |
  | \**    | 幂运算   |
  | <<     | 左位移   |
  | >>     | 右位移   |
  | &      | 位布尔和 |
  | 竖线   | 位布尔或 |
  | &&     | 逻辑和   |
  | 双竖线 | 逻辑或   |
- 双方括号
  双括号只能对进行数学表达是运算,通俗来说就是运算对象只能是数值
  而双方括号则是test检测字符串的升级
  它提供了模式匹配功能,并且可以使用正则表达式进行匹配
**** case命令
其功能类似于switch
#+begin_src shell
case v in
p1 | p2) commands1;;
p3) commands2;;
*) default commands;;
esac
#+end_src
其含义为若变量v与p1或p2匹配则执行commands1
若与p3匹配则执行commands2
若都不满足则执行commands
**** for语句
#+begin_src shell
  list="a b c d"
    for var in list
    do
        echo "--$var"
    done
#+end_src
上面语句会输出
#+begin_example
--a
--b
--c
--d
#+end_example
这是因为for会自动对list进行分割,在shell中存在一个IFS环境变量定义了
shell用作字段分隔符的一系列字符,默认情况下shell会将空格,制表符,换行符作为分割符
同时,通过修改IFS变量可以修改分割规则
#+begin_src shell
IFS="/"
list="a/b/c"
for val in list
do
    echo  "$val"
done
#+end_src
上面示例shell会将'/'作为分隔符,及会依次换行输出a,b,c而'//'作为分隔符不会输出
**** C语言风格的for
#+begin_src shell
for (( a = 1; a < 10; a++ ))
do
...
done
#+end_src
**** whle语句
- 从10输出到1
      #+begin_src shell
        var1=10
          while [ $var1 -gt 0 ]
          do
          echo $var1
          var1=$[ $var1 - 1 ]
#+end_src
- while使用多个测试命令
  #+begin_src shell
#!/bin/bash
# testing a multicommand while loop10
var1=1011
while echo $var1
[ $var1 -ge 0 ]
do
echo "This is inside the loop"
  #+end_src
  示例中的while后有两个测试语句,但while将最后一个语句的退出码做判断
  而位于它前面的语句只做执行,不用做while的判断
**** unit语句
与while语法相同但作用相反,只有测试语句的退出码返回0才会退出until
#+begin_src shell
until   条件
do
...
done
#+end_src
**** 循环控制
- break
  与C语言的break功能相似,但shell中的break可以指定参数
  来表示退出的循环的级别,默认是1即退出当前循环
- continue
  与C语言的continue功能相似,不过它也能指定参数表示要继续执行的循环的级别
*** 处理用户输入
**** 参数
在shell脚本中用$0表运行的程序,$1表第一个参数,$2表第二个参数依次类推
**** 特殊参数变量
- $#表示传入shell中的参数个数
- $*和$@变量可以用来轻松访问所有的参数
  两者都会将所有传给shell的变量作为它的值
  $*会将所有传给shell的参数当作整体处理
  $@则可以单独处理
  即在使用for时,如果将$*作为list则不会对其中包含的变量进行拆分
  而$@则可以
**** 移动参数
shift命令可以实现移动参数,即shfit可以将所有参数(不包括$0)往左移动
也就是使用shift后$1的值会等于$2,$2会等于$3,以此类推,而$1初始值会被丢弃
**** 获得用户输入
基本格式:read  name
将用户输入的内容复制给name
*** 呈现数据
**** 标准文件描述符
linux的文件描述符是一个非负整数，可以唯一标识会话中打开的文件。
每个进程一次最多可以有九个文件描述符。出于特殊目的，bash shell保留了
前三个文件描述符
| 文件描述符 | 所写   | 描述     |
|------------+--------+----------|
|          0 | STDIN  | 标准输入 |
|          1 | STDOUT | 标准输出 |
|          2 | STDERR | 标准错误 |
- STDIN
  STDIN文件描述符对应的键盘获得输入，在用户输入时处理每个字符。
  在使用输入重定向符号（<）时，Linux会用重定向指定的文件来替换标准输入文件描述符
  例如cat命令在不加任何参数的情况下就会从STDIN接受输入,用户输入一行显示一行
  但你也可以通过STDIN重定向符号强制cat命令接受来自另一个非STDIN文件的输入。
  使用'cat < 文件名'
- STDOUT
  默认情况下STDOUT标准输出就是显示器,而shell所有的所有的输出(包括脚本)都会
  重定向到STDOUT中,即会输出在显示器
  我们可以通过'>'强制将其输出到某个文件中
- STDERR
  shell产生的错误都会重定向到这里,而STDERR默认情况下与STDOUT指向同一位置
  也就是说shell产生的错误也会输出到显示器
**** 重定向错误
- 只重定向错误
  STDERR文件描述符被设成2。可以选择只重定向错误消息，
  将该文件描述符值放在重定向符号前。该值必须紧紧地放在重定向符号前，否则不会工作。
  #+begin_src shell
ls  dir  2>  test
  #+end_src
  这样如果dir文件存在那么此命令就与'ls dir'效果相同,
  若不存在则错误不会输出的显示器,而会被输出的test文件
- 重定向错误和数据
  若只用'2>'进行重定向那么对错误重定向,而正确内容则仍会显示在显示器上
  * 示例
    #+begin_src shell
      ls  dir1  dir2   2>  test
    #+end_src
    假设dir1存在,而dir2不存在那么dir1目录的内容会正确显示到显示器上
    而'ls dir2'的错误会输出到test文件
  要实现数据和错误都重定向可以使用'&>'表所有输出都会被重定向
  或同时使用'1>'和'2>'表重定向输入和输出
  #+begin_src  shell
    #表正常输出重定向到test2,错误输出重定向到test1
    ls   dir1   dir2   2>  test1    1>  test2
    #所有输出重定向到test
    ls   dir1     dir2   &>      test
  #+end_src
**** 脚本重定向输出
***** 临时重定向
在shell脚本中允许使用临时重定向某条命令
- 示例
  #+begin_src
    echo  "error message"  >&2
    echo  "normal message"
  #+end_src
  在此脚本中'>&2'中2表示STDERR的文件描述符,
  第一条语句表示将该命令重定向到STDERR中
  由于STDERR和STDOUT的输出都指向显示器,所以在正常执行是看不出差别
  但如果将该脚本执行的STDERR重定向到某个文件时,那么第一条语句就会显示在文件上,
  而第二条语句则会正常在显示器中显示
***** 永久重定向
在脚本中使用'exec  文件描述符>文件名'可以重定向某个特定的文件描述符
- 示例
  #+begin_src shell
    #将STDERR重定向到test1
    exec   2>test1
    #将STDOUT重定向到test2
    exec   1>test2
  #+end_src
**** 脚本重定向输入
与重定向输出格式相同'exec 0<filename'
表示从filename中获取输入而非STDIN
**** 创建文件描述符
使用exec命令也可以用于创建文件描述符
- 示例
  创建输出文件描述符:exec 文件描述符>filename
  创建输入文件描述符:exec 文件描述符<filename
  文件描述符间进行操作:
  exec 3>&1
  exec 1>filename
其实也可以这样理解当'exec'用于对文件描述符做操作时,若文件描述符存在
则该功能为重定向文件描述符,否则为创建文件描述符]
**** 关闭文件描述符
若在shell中自己创建了描述符则在shell结束后会自动关闭,
当然也可以提前关闭
- 示例
  关闭输出文件描述符3:exec 3>&-
**** 列出打开的文件描述符
lsof命令会列出整个Linux系统打开的所有文件描述符,
但这数量太庞大了,所以lsof有许多过滤参数,例如'-p'指定进程id(pid)
'-d'指定文件文件描述符的编号,'-a'选项可以是指定参数的结果进行and运算
- 示例
  lsof -a -p $$ -d 0,1,2
'$'为特殊变量shell会将它的值设为当前pid.
其含义为列出文件pid为'$'的文件描述符,并且只列出文件描述符为0,1,2的
**** 阻止命令输出
在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉
- 示例
  ls fsd 2> //dev/null/
其含义通俗来说就是丢弃错误
*** 控制脚本
**** linux常见信号
不同的Linux信号以及Linux如何用这些信号来停止、启动、终止进程。
可以通过对脚本进行编程，使其在收到特定信号时执行某些命令，从而控制shell脚本的操作。
以下是linux常见信号
| 信号 | 值      | 描述                           |
|------+---------+--------------------------------|
|    1 | SIGHUP  | 挂起进程                       |
|    2 | SIGINT  | 终止进程                       |
|    3 | SIGQUIT | 停止进程                       |
|    9 | SIGKILL | 无条件终止进程                 |
|   15 | SIGTERM | 尽可能终止进程                 |
|   17 | SIGSTOP | 无条件停止进程，但不是终止进程 |
|   18 | SIGTSTP | 停止或暂停进程，但不终止       |
|   19 | SIGCONT | 继续运行停止的进程             |
**** 信号生成
- 中断进程
  ctrl-c会产生SIGINT
- 停止进程
  ctrl-z会产生SIGTSTP它会停止进程但不会终止,
  进程仍存在内存中,并且可以重新从上一个停止的位置运行
**** 捕获信号
trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。
如果脚本收到了trap命令列出的信号,该信号将不再有shell处理,而是交由本地出处理
格式:trap 命令 信号值
- 示例
  trap ls SIGINT
表示每次中断是都会执行'ls'命令
**** 后台运行
- 普通后台运行
  在命令后加'&'即可
- 在非控制台下运行脚本
  nohup command &
  与普通后台运行不同的是即是终端被关闭了该命令仍会执行到结束
  并且命令中存在的输出也不会输出到终端,而是会在本文件夹新建一个nohup.out的文件作为输出
**** 重启停止的作业
我们上面讲到可以用ctrl-z暂停进程,
而继续该进程的命令为'bg'或'fg'
bg和fg分别为后台和前台启动,若是后台启动则操作提示符会立即出现,
即你可以立即在该终端做其他事,而前台的话需要等命令结束才行
格式:bg(fg) [作业号]
**** linux调度
调度优先级是个整数值，从-20（最高优先级）到+19（最低优先级）。默认情况下，bash shell
以优先级0来启动所有进程。
***** nice命令
用于命令启动时修改优先级
- 格式
  nice -n 优先级别 命令
  或者
  nice -优先级别  命令
注意普通用户使用nice命令只能减低优先级,不能提高
***** renice命令
用于对已经启动的命令修改其优先级
- 格式
  renice -n 优先级别 命令
与nice命令一样普通用户只能降低优先级
*** 函数
**** 创建函数
#+begin_src shell
    function name
    {
    ...
  }
    #或者
    name ()
    {
    ...
  }
#+end_src
**** 函数返回值
默认情况下函数返回值为函数的最后一条语句的退出码
也可以使用'return'返回特定的值
亦或是将函数的输出作为返回值
**** 变量作用域
默认情况下,无论实在外部创建变量,亦或是函数内部创建变量都是全局变量
只有在变量前加上'local'关键字才会是变量成为局部变量
**** 函数与数组
***** 将数组变量传递给函数
在shell中如果将整个数组传递给函数,那么函数只会去数组的第一个值,
正确的做法是将数组拆分成单个值在传递给函数
#+begin_src shell
  function test
  {
  fun1()
{
    local newarry=(`echo "$@"`)
    echo "${newarry[*]}"
}

myarray=(1 2 3 4)
fun1 ${myarray[*]}

}
#+end_src
**** 从函数中返回数组
从函数里向shell脚本传回数组变量也用类似的方法。
函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中。
**** 库文件
在shell中允许一个脚本使用其他脚本的函数或变量,只需要在脚本中引入即可
假设引入的脚本在与当前脚本在同一目录
#+begin_src shell
  source  ./脚本
  或者
  .   ./脚本
#+end_src
注意:如果在脚本A中直接执行需要引入的脚本B这样是不能使用脚本B中的函数或变量的
因为但你在脚本A中执行引入的脚本B时,shell会为脚本B会创建一个shell来执行该脚本
所以使用这种方法执行的脚本A和脚本B不在同一shell环境中,故不能使用脚本B中定义的函数或变量
*** 图形化桌面环境中的脚本编程
**** 创建文本菜单
使用函数实现简单的菜单功能
#+begin_src shell
#!/bin/bash

#列出菜单选项
function menu
{
    clear
    echo
    echo -e "\t\t\tSys Admin Menu\n"
    echo -e "\t1. Display disk space"
    echo -e "\t2. Display logged on users"
    echo -e "\t3. Display memory usage"
    echo -e "\t0. Exit menu\n\n"
    echo -en "\t\tEnter option: "
    #获取用户输入
    read -n 1  option
}

function diskspace
{
    clear
    df -k
}

function whoseon
{
    clear
    who
}

function menmusage
{
    clear
    cat /proc/meminfo
}

while [ 1 ]
do
menu

case $option in
    0)
        break;;
    1)
        diskspace;;
    2)
        whoseon;;
    3)
        menmusage;;
    *)
        clear
        echo "error";;
esac
echo -en "\n\npress enter to continue"
read -n 1 line
done
clear

#+end_src
也可以使用selece命令,这样我们就不用对选项进行排版了,select命令会自动帮我们进行排版
#+begin_src shell
#!/bin/bash

#使用select命令实现创建菜单

function diskspace {
clear
df -k
}
function whoseon {
clear
who
}

function memusage {
clear
cat /proc/meminfo
}


PS3="Enter option: "

select option in "Display disk space" "Display logged on users" "Display memory usage" "Exit program"
do
case $option in
"Exit program")
break ;;
"Display disk space")
diskspace ;;
"Display logged on users")
whoseon ;;
"Display memory usage")
memusage ;;
*)
clear
echo "Sorry, wrong selection";;
esac
done
clear
#+end_src
**** dialog包
在上面我制作了简单的文本菜单,虽然也实现了我们想要的功能,但是太过简陋了
因此用开源爱好者开发了dialog包,该包能够用ANSI转义控制字符在文本环境中创建标准的窗口对话框。
你可以轻而易举地将这些对话框融入自己的shell脚本中，借此与用户进行交互。
- dialog包常用部件
  | 部件         | 描述                                               |
  |--------------+----------------------------------------------------|
  | calendar     | 提供选择日期的日历                                 |
  | checklist    | 显示多个选项（其中每个选项都能打开或关闭）         |
  | form         | 构建一个带有标签以及文本字段（可以填写内容）的表单 |
  | fselect      | 提供一个文件选择窗口来浏览选择文件                 |
  | gauge        | 显示完成的百分比进度条                             |
  | infobox      | 显示一条消息，但不用等待回应                       |
  | inputbox     | 提供一个输入文本用的文本表单                       |
  | inputmenu    | 提供一个可编辑的菜单                               |
  | menu         | 显示可选择的一系列选项                             |
  | msgbox       | 显示一条消息，并要求用户选择OK按钮                 |
  | pause        | 显示一个进度条来显示暂定期间的状态                 |
  | passwordbox  | 显示一个文本框，但会隐藏输入的文本                 |
  | passwordform | 显示一个带标签和隐藏文本字段的表单                 |
  | radiolist    | 提供一组菜单选项，但只能选择其中一个               |
  | tailbox      | 用tail命令在滚动窗口中显示文件的内容               |
  | tailboxbg    | 跟tailbox一样，但是在后台模式中运行                |
  | textbox      | 在滚动窗口中显示文件的内容                         |
  | timebox      | 提供一个选择小时、分钟和秒数的窗口                 |
  | yesno        | 提供一条带有Yes和No按钮的简单消息                  |
使用方式:
dialog --widget para
其中widget的值可以是上面表格中的任意一个,para则是widget的参数比如说要显示的宽度,高度之类的
dialog每个部件都提供两种输出新式
1. 使用STDERR
2. 使用退出状态码
dialog退出码通常用来确定用户选择的按钮,比如选择yes会返回退出码0
选择no会返回退出码1,通过$?可获得返回的退出码
而dialog的部件如果返回了数据则会被发送到STDERR
dialog不仅提供了基础的部件,同时还提供了一些选项使得部件的功能和外观能够更完善
- dialog选项
  | 选项                     | 描述                                                             |
  |--------------------------+------------------------------------------------------------------|
  | --add-widget             | 继续下个对话框，直到按下Esc或Cancel按钮                          |
  | --aspect ratio           | 指定窗口宽度和高度的宽高比                                       |
  | --backtitle title        | 指定显示在屏幕顶部背景上的标题                                   |
  | --begin x y              | 指定窗口左上角的起始位置                                         |
  | --cancel-label label     | 指定Cancel按钮的替代标签                                         |
  | --clear                  | 用默认的对话背景色来清空屏幕内容                                 |
  | --colors                 | 在对话文本中嵌入ANSI色彩编码                                     |
  | --cr-wrap                | 在对话文本中允许使用换行符并强制换行                             |
  | --create-rc file         | 将示例配置文件的内容复制到指定的file文件中①                     |
  | --defaultno              | 将yes/no对话框的默认答案设为No                                   |
  | --default-item string    | 设定复选列表、表单或菜单对话中的默认项                           |
  | --exit-label label       | 指定Exit按钮的替代标签                                           |
  | --extra-button           | 在OK按钮和Cancel按钮之间显示一个额外按钮                         |
  | --extra-label label      | 指定额外按钮的替代标签                                           |
  | --help                   | 显示dialog命令的帮助信息                                         |
  | --help-button            | 在OK按钮和Cancel按钮后显示一个Help按钮                           |
  | --help-label label       | 指定Help按钮的替代标签                                           |
  | --help-status            | 当选定Help按钮后，在帮助信息后写入多选列表、单选列表或表单信息   |
  | --ignore                 | 忽略dialog不能识别的选项                                         |
  | --input-fd fd            | 指定STDIN之外的另一个文件描述符                                  |
  | --insecure               | 在password部件中键入内容时显示星号                               |
  | --item-help              | 为多选列表、单选列表或菜单中的每个标号在屏幕的底部添加一个帮助栏 |
  | --keep-window            | 不要清除屏幕上显示过的部件                                       |
  | --max-input size         | 指定输入的最大字符串长度。默认为2048                             |
  | --nocancel               | 隐藏Cancel按钮                                                   |
  | --no-collapse            | 不要将对话文本中的制表符转换成空格                               |
  | --no-kill                | 将tailboxbg对话放到后台，并禁止该进程的SIGHUP信号                |
  | --no-label label         | 为No按钮指定替代标签                                             |
  | --no-shadow              | 不要显示对话窗口的阴影效果                                       |
  | --ok-label label         | 指定OK按钮的替代标签                                             |
  | --output-fd fd           | 指定除STDERR之外的另一个输出文件描述符                           |
  | --print-maxsize          | 将对话窗口的最大尺寸打印到输出中                                 |
  | --print-size             | 将每个对话窗口的大小打印到输出中                                 |
  | --print-version          | 将dialog的版本号打印到输出中                                     |
  | --separate-output        | 一次一行地输出checklist部件的结果，不使用引号                    |
  | --separator string       | 指定用于分隔部件输出的字符串                                     |
  | --separate-widget string | 指定用于分隔部件输出的字符串                                     |
  | --shadow                 | 在每个窗口的右下角绘制阴影                                       |
  | --single-quoted          | 需要时对多选列表的输出采用单引号                                 |
  | --sleep sec              | 在处理完对话窗口之后延迟指定的秒数                               |
  | --stderr                 | 将输出发送到STDERR（默认行为）                                   |
  | --stdout                 | 将输出发送到STDOUT                                               |
  | --tab-correct            | 将制表符转换成空格                                               |
  | --tab-len n              | 指定一个制表符占用的空格数（默认为8）                            |
  | --timeout sec            | 指定无用户输入时，sec秒后退出并返回错误代码                      |
  | --title title            | 指定对话窗口的标题                                               |
  | --trim                   | 从对话文本中删除前导空格和换行符                                 |
  | --visit-items            | 修改对话窗口中制表符的停留位置，使其包括选项列表                 |
  | --yes-label label        | 为Yes按钮指定替代标签                                            |
**** 其他图形窗口部件包
由于dialog包只提供非常基础的功能,并且界面仍不够美观
所以各大桌面环境基本上都是使用自己开发的窗口部件包
像kde,gnome就分别使用了kdialog和zenity包
其实两者都是在dialog的思路上扩展的,相较于dialog可能kdialog和zenity的功能可能会
更为强大,且界面更加美观.但使用方式基本上都是相似的
*** sed和gawk
**** sed介绍
sed编辑器被称作流编辑器(stream editor),流编辑器则会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流。
sed编辑器可以根据命令来处理数据流中的数据，
- sed编辑器工作方式
  1. 一次从输入中读取一行数据。
  2. 根据所提供的编辑器命令匹配数据。
  3. 按照命令修改流中的数据。
  4. 将新的数据输出到STDOUT。
- sed使用的基本格式
  sed option script file
- sed命令选项
  | 选项      | 描述                                                 |
  |-----------+------------------------------------------------------|
  | -e script | 在处理输入时，将script中指定的命令添加到已有的命令中 |
  | -f file   | 在处理输入时，将file中指定的命令添加到已有的命令中   |
  | -n        | 不产生命令输出，使用print命令来完成输出              |
      - 示例
        echo "this is a test" | sed "s/test/aa/"
        或使用 sed "s/test/aa/" 某个文件
        其中sed后字符串第一个字符's'表示使用sed的's'命令,s命令会用斜线间指定的第二个文本字符串来替换第
        一个文本字符串模式.
        其含义为将"this is a test"中的'test'替换为'aa'
        注意's'命令只会替换每行第一个出现的字符串
        如果上述命令是:echo "this is a test test" | sed "s/test/aa/"
        那么输出将会是"this is a aa test"而不是"this is a aa aa"
        使用多个命令:sed -e "s/test/aa/;s/dog/cat" data.txt
        使用文件内容作为命令:sed -f 文件名 data.txt
**** gawk介绍
gawk程序是Unix中的原始awk程序的GNU版本.它提供了一种编程语言而不只是编辑器命令
gawk和sed一样是属于流编辑器,因此gawk每次也只会读取一行内容
- 使用gawk可以实现
  + 定义变量来保存数据；
  + 使用算术和字符串操作符来处理数据；
  + 使用结构化编程概念（比如if-then语句和循环）来为数据处理增加处理逻辑；
  + 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告。
- gawk格式
  gawk option program file
  选项
  | 选项         | 描述                               |
  |--------------+------------------------------------|
  | -F fs        | 指定行中划分数据字段的字段分隔符   |
  | -f file      | 从指定的文件中读取程序             |
  | -v var=value | 定义gawk程序中的一个变量及其默认值 |
  | -mf N        | 指定要处理的数据文件中的最大字段数 |
  | -mr N        | 指定数据文件中的最大数据行数       |
  | -W keyword   | 指定gawk的兼容模式或警告等级       |
- gawk中的数据字段变量
  $0代表整个文本行
  $1代表文本行中第一个数据段
  $2代表文本行中第二个数据段
  $n代表文本行中第n个数据段
**** sed基础
***** 替换标记
在前面演示的's'适用于替换文本,同时它还支持替换标记
- 格式
  s/匹配字符/替换的文本/替换标记
不加替换标记默认是替换每行第一个出现的匹配字符串
- 替换标记
  | 替换标记 | 功能                                   |
  |----------+----------------------------------------|
  | 数字     | 表明新文本将替换第几处模式匹配的地方； |
  | g        | 表明新文本将会替换所有匹配的文本；     |
  | p        | 表明原先行的内容要打印出来；           |
  | w file   | 将替换的结果写到文件中。               |
- 地址
  在sed的操作中允许指定对某行或某些行进行操作,这种操作被称作'行寻址',通常有两种寻址方式
  1. 以数字形式表示行区间
     + 只修改指定行内容
       sed '2s/dog/cat/' data.txt
       只修改第2行内容
     + 使用区间
       sed '2,5s/dog/cat/' data.txt
       修改第2-5行的内容
     + 从某行到结尾
       sed '2,$/dog/cat/' data.txt
       使用$可表示为到文件结尾位置
  2. 用文本模式过滤出行
     sed '//the/s/cat/dog//' data.txt
     表示只修改含'the'的行,其中'the'这个位置也可以使用正则表达式
***** 删除操作
前面讲的's'是替换命令,而'd'则是sed的删除命令
sed 'd' data.txt
不加参数会将所以内容删除
所以命令'd'一般会与地址一起使用,并且其使用方式与替换的几乎相同
需要注意的是当使用了两个文本匹配时,第一个文本匹配代表开启删除模式,
而第二个则代表关闭删除模式
例如
#+begin_example data.txt
This is line number 1.
This is line number 2.
This is line number 3.
This is line number 4.
This is line number 1 again.
This is text you want to keep.
This is the last line in the file.
#+end_example
当对上面文件进行下面的操作时,其过程是:
第一行有1与命令中的模式相匹配,故开启删除模式,而此时一直到第三行删除模式都未关闭
所以前面3行内容都会被删除,到第4行由于删除模式已关闭并且也没有匹配所以第4行内容保留,
到第5行有匹配了此时由于一直到结尾都没有与模式相匹配的行来关闭删除模式故会一直删除知道结尾
所以,一下命令输出是:This is line number 4
#+begin_src shell
  sed "/1./3/d" data.txt
#+end_src
***** 插入和附加操作
插入和附加操作命令分别是'i'和'a',插入操作的内容会出现在流的前面,而附加则会出现在流的后面
两者也支持寻址插入和附加
- 将数据插入到第3行前面
  sed '3i/插入的数据' data.txt
- 将数据附加到第3行后面
  sed '3a/追加的数据' data.txt
***** 修改操作
修改命令是'c',记得与替换区分开来,修改操作是将一整行的内容都有进行修改
其使用方式与替换一样,但效果不同
例如:sed '2,5cfff' data.txt
其作用是将2-5行的内容修改为fff,而不是2-5行的每行内容都是修改为fff
***** 转换命令
转换命令是'y',它是一个处理字符的命令
格式:[address]y/inchar/outchar/
inchar到outchar可理解为是映射y命令会将inchar中的字符装换为outchar对应额度字符
即如果某个字符出现在inchar第一个位置,那么它也会被替换为outchar的第一个位置
***** 打印命令
****** 打印行命令
与替换标记一样,打印命令也是'p'
格式:[address]p
****** 打印行号
格式:[address]=
****** 列出行
格式:[address]l
***** sed文件处理
****** 写入文件
前面我们所有的操作如果不加写入操作的话,其实都不会对文件本身产生任何影响
格式:[address]w filename
****** 读取文件
读取命令'r'允许你将一个独立文件中的数据插入到数据流中。
格式:[address]r filename
例如:sed '3r insertfile' filename
此命令会将insertfile中的内容插入到filename的第3行后面
*** sed进阶
**** next命令
***** 单行版本next
及小写n命令,小写的n命令会告诉sed编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始
例如
#+begin_example data.txt
test

aaa

bbb
ccc

ddd
#+end_example
若此时我们想删除test下一行的空行,而保留其他空行我们此时可以使用n命令
sed '/test/{n;d}' data.txt
此命令的执行流程为首先找到test所在的行后n,会先执行n命令将将数据流移动到下一行
即我们想删除的空行然后在做d命令将整行删除,而由于之后没有与test相匹配的文本
所以该命令只删除了test后的空行
***** 合并文本行
即大写的N命令,多行版本的next命令（用大写N）会将下一文
那上面当行版本的例子来说,如果我们执行以下命令
sed '/test/{N;d}' data.txt
那么此时test行也会被删除,因为此命令是会将test及test下一行的内容当作整体处理
注意当作整体处理,所以test和其下一行其实还是有换行符'\n'存在的
**** 模式空间
是一块活跃的缓冲区,在我们使用sed命令读取每行文本时,该文本就是放到模式空间的
**** 保持空间
sed编辑器的另一个缓冲区,通常用来保存模式空间的一些临时东西
- 对保持空间的操作
  | 命令 | 描述                         |
  |------+------------------------------|
  | h    | 将模式空间复制到保持空间     |
  | H    | 将模式空间附加到保持空间     |
  | g    | 将保持空间复制到模式空间     |
  | G    | 将保持空间附加到模式空间     |
  | x    | 交换模式空间和保持空间的内容 |
**** 排除命令
排除命令(!),可理解为编程语言中的非操作,在sed中即是执行原来操作相反的操作
举例来说
sed -n '/aaa/p' data.txt
其含义为打印行中包括'aaa'的行
而若加上排除命令
sed -n '//aaa//!p' data.txt
其含义就变成了打印不包含'aaa'行的行
**** 分支
排除命令可支持对命令进行排除,sed也提供了基于地址进行排除的方式我们称作分支(branch)
格式:[address]b [label]
address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置,如果没有默认跳转到末尾
示例1:sed '{2,5b;s/aaa/bbb/}' data.txt
其作用是将每行出现的第一个'aaa'替换为'bbb'但不包括2-5行
示例2:sed '{//first/b jump1;s/aaa/bbb//;:jump1;s/aaa/ccc/}' data.txt
其作用是遇到与'first'匹配的行则跳到:jump1出执行接着执行命令,否则正常顺序执行
**** 测试命令
与分支命令类似,但测试命令(t)是依据替换结果进行调整的,
如果我们已经做了一次替换而不需要在做另一个替换是就可以使用测试命令
例如:sed '{s/aaa/bbb/;t;s/ccc/ddd/}' data.txt
以上含义即为若我们匹配到aaa则将其替换为bbb,继续向下执行t时,t检测到已经进行过一次替换了
t就会是命令跳转,由于此时t没有指定标签,那么就会默认跳转到末尾,而若第一条命令没有发生替换
那么t就不会跳转,而继续向下执行
**** &符号
在sed的替换命令中'&'符号可以代替被替换的文本
例如:sed 's/aaa/"&"/ data.txt
其含义为将aaa提换为"aaa",这在一般情况下也许毫无意义因为我们完全可以使用
sed 's/aaa/"aaa"/'替代,但如果要被替换的内容是一个正则表达式,这就显得很有意义了
*** gawk进阶
**** 内置变量
| 变量        | 描述                                                 |
|-------------+------------------------------------------------------|
| FIELDWIDTHS | 由空格分隔的一列数字，定义了每个数据字段确切宽度     |
| FS          | 输入字段分隔符                                       |
| RS          | 输入记录分隔符                                       |
| OFS         | 输出字段分隔符                                       |
| ORS         | 输出记录分隔符                                       |
| ARGC        | 当前命令行参数个数                                   |
| ARGIND      | 当前文件在ARGV中的位置                               |
| ARGV        | 包含命令行参数的数组                                 |
| CONVFMT     | 数字的转换格式（参见printf语句），默认值为%.6 g      |
| ENVIRON     | 当前shell环境变量及其值组成的关联数组                |
| ERRNO       | 当读取或关闭输入文件发生错误时的系统错误号           |
| FILENAME    | 用作gawk输入数据的数据文件的文件名                   |
| FNR         | 当前数据文件中的数据行数                             |
| IGNORECASE  | 设成非零值时，忽略gawk命令中出现的字符串的字符大小写 |
| NF          | 数据文件中的字段总数                                 |
| NR          | 已处理的输入记录数                                   |
| OFMT        | 数字的输出格式，默认值为%.6 g                        |
| RLENGTH     | 由match函数所匹配的子字符串的长度                    |
| RSTART      | 由match函数所匹配的子字符串的起始位置                |
**** 自定义变量
gawk中的自定义变量与shell中的赋值语句相同
示例:gawk 'BEGIN{var="aaa";print var}'
同时gawk也直接在命令行中定义变量
**** 数组
***** 定义数组
定义数组的方式与定义变量类似
格式:var[index]=element
'var'为数组名,index关联数组的索引值,这个与我们常见编程语言的数组不太一样
常见编程语言的index值是数字,而在这里却不仅可以是数字还可以是字符串,'element'为元素
- 例如
  capital["Illinois"] = "Springfield"
  capital["Indiana"] = "Indianapolis"
  capital["Ohio"] = "Columbus"
***** 遍历数组
遍历数组可以使用一种特殊形式的for
#+begin_example
$ gawk 'BEGIN{
> var["a"] = 1
> var["g"] = 2
> var["m"] = 3
> var["u"] = 4
> for (test in var)
> {
>
print "Index:",test," - Value:",var[test]
> }
> }'
Index: u - Value: 4
Index: m - Value: 3
Index: a - Value: 1
Index: g - Value: 2
$
#+end_example
***** 删除数组变量
删除数组索引即可删除给数组索引的值
格式:delete array[index]
**** 通配符
通配符'~'可以指定匹配操作符、数据字段变量以及要匹配的正则表达式。
例如:gawk 'BEGIN{FS=","} $2 ~ /^aa/{print $0}' data.txt
此命令中$2表示第二个字段,而使用了通配符后就此命令就表示匹配第二个字段以'aa'开头的文本
**** 数学表达式
在gawk中使用数学表达式进行过滤
其使用方式与常见编程语言类似,直接指明要匹配的字段和匹配方式即可
例如:gawk -F: '$4==0{print $1}' /etc/passwd
表示打印第4个字段等于0的文本的第一个字段
- 常用数学表达式
  | 表达式 | 描述           |
  |--------+----------------|
  | x==y   | 值x等于y。     |
  | x <= y | 值x小于等于y。 |
  | x < y  | 值x小于y。     |
  | x >= y | 值x大于等于y。 |
  | x > y  | 值x大于y。     |
**** 结构化命令
***** if语句
格式:if (condition) statement1
if (condition) statement1; else statement2
***** while语句
格式:
while (condition)
{
statements
}
***** do-while语句
格式:
do
{
statements
} while (condition)
***** for语句
与c语言的for类似
格式:for( variable assignment; condition; iteration process)
#+begin_example
$ gawk '{
> total = 0
> for (i = 1; i < 4; i++)
> {
>
total += $i
> }
> avg = total / 3
> print "Average:",avg
> }' data5
Average: 128.333
Average: 137.667
Average: 176.667
$
#+end_example
**** 格式化输出
gawk的格式化输出与C语言类似
格式:printf "format string", var1, var2 . . .
- 格式化输出的控制字母
  | 控制字母 | 描述                                       |
  |----------+--------------------------------------------|
  | c        | 将一个数作为ASCII字符显示                  |
  | d        | 显示一个整数值                             |
  | i        | 显示一个整数值（跟d一样）                  |
  | e        | 用科学计数法显示一个数                     |
  | f        | 显示一个浮点值                             |
  | g        | 用科学计数法或浮点数显示（选择较短的格式） |
  | o        | 显示一个八进制值                           |
  | s        | 显示一个文本字符串                         |
  | x        | 显示一个十六进制值                         |
  | X        | 显示一个十六进制值，但用大写字母A~F        |
#+begin_example
$ gawk 'BEGIN{
> x = 10 * 100
> printf "The answer is: %e\n", x
> }'
The answer is: 1.000000e+03
$
#+end_example
除了控制字母外，还有3种修饰符可以用来进一步控制输出。
- width
  指定了输出字段最小宽度的数字值。如果输出短于这个值，printf会将文本右
  对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。
- prec
  这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的最
  大字符数。
- -（减号）
  指明在向格式化空间中放入数据时采用左对齐而不是右对齐。
#+begin_example e
$ gawk 'BEGIN{FS="\n"; RS=""} {printf "%16s %s\n",$1,$4}' data.txt
  Riley Mullen (312)555-1234
Frank Williams (317)555-9876
   Haley Snell (313)555-4938
$
%s\n", $1, $4}' data2
#+end_example
其中的16就表示第一个输出的字段的宽度为16,从输出中也不难看出,第一行和第三行的输出
由于第一个字段的字符不满16个则会用空格补齐
而这样不够美观所以我们可以修改它的对齐方式
#+begin_example e
$ gawk 'BEGIN{FS="\n"; RS=""} {printf "%-16s %s\n",$1,$4}' data.txt
Riley Mullen (312)555-1234
Frank Williams (317)555-9876
Haley Snell (313)555-4938
$
%s\n", $1, $4}' data2
#+end_example
**** 内置函数
***** 数学函数
| 函数        | 描述                          |
|-------------+-------------------------------|
| atan2(x, y) | x/y的反正切，x和y以弧度为单位 |
| cos(x)      | x的余弦，x以弧度为单位        |
| exp(x)      | x的指数函数                   |
| int(x)      | x的整数部分，取靠近零一侧的值 |
| log(x)      | x的自然对数                   |
| rand( )     | 比0大比1小的随机浮点值        |
| sin(x)      | x的正弦，x以弧度为单位        |
| sqrt(x)     | x的平方根                     |
| srand(x)    | 为计算随机数指定一个种子值    |
***** 按位操作数据的函数
| 函数               | 描述                         |
|--------------------+------------------------------|
| and(v1, v2)        | 执行值v1和v2的按位与运算。   |
| compl(val)         | 执行val的补运算。            |
| lshift(val, count) | 将值val左移count位。         |
| or(v1, v2)         | 执行值v1和v2的按位或运算。   |
| rshift(val, count) | 将值val右移count位。         |
| xor(v1, v2)        | 执行值v1和v2的按位异或运算。 |
***** 字符串函数
| 函数                      | 描述                                                                                                  |
|---------------------------+-------------------------------------------------------------------------------------------------------|
| asort(s [,d])             | 将数组s按数据元素值排序。索引值会被替换成表示新的排序顺序的连续数字。                                 |
|                           | 另外，如果指定了d，则排序后的数组会存储在数组d中                                                      |
| asorti(s [,d])            | 将数组s按索引值排序。生成的数组会将索引值作为数据元素值，                                             |
|                           | 用连续数字索引来表明排序顺序。另外如果指定了d，排序后的数组会存储在数组d中                            |
| gensub(r, s, h [, t])     | 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。                                          |
|                           | 如果h是一个以g或G开头的字符串，就用s替换掉匹配的文本。如果h是一个数字，它表示要替换掉第h处r匹配的地方 |
| gsub(r, s [,t])           | 查找变量$0或目标字符串t（如果提供了的话）来匹配正则表达式r。如果找到了，就全部替换成字符串s           |
| index(s, t)               | 返回字符串t在字符串s中的索引值，如果没找到的话返回0                                                   |
| length([s])               | 返回字符串s的长度；如果没有指定的话，返回$0的长度                                                     |
| match(s, r [,a])          | 返回字符串s中正则表达式r出现位置的索引。如果指定了数组a，它会存储s中匹配正则表达式的那部分            |
| split(s, a [,r])          | 将s用FS字符或正则表达式r（如果指定了的话）分开放到数组a中。返回字段的总数                             |
| sprintf(format,variables) | 用提供的format和variables返回一个类似于printf输出的字符串                                             |
| sub(r, s [,t])            | 在变量$0或目标字符串t中查找正则表达式r的匹配。如果找到了，就用字符串s替换掉第一处匹配                 |
| substr(s, i [,n])         | 返回s中从索引值i开始的n个字符组成的子字符串。如果未提供n，则返回s剩下的部分                           |
| tolower(s)                | 将s中的所有字符转换成小写                                                                             |
| toupper(s)                | 将s中的所有字符转换成大写                                                                             |
***** 时间函数
| 函数                         | 描述                                                                                       |
|------------------------------+--------------------------------------------------------------------------------------------|
| mktime(datespec)             | 将一个按YYYY MM DD HH MM SS [DST]格式指定的日期转换成时间戳值①                            |
| strftime(format[,timestamp]) | 将当前时间的时间戳或timestamp（如果提供了的话）转化格式化日期（采用shell函数date()的格式） |
| systime( )                   | 返回当前时间的时间戳                                                                       |
**** 自定义函数
- 定义函数
  格式:
  #+begin_example fun
  function name([variables])
{
statements
[return value]
}
  #+end_example
- 使用函数
  使用函数的方式与使用内置函数的方式并无产别,只不过我们在使用自定义函数前需要先进行定义
  #+begin_example funexp
$ gawk '
> function myprint()
> {
>   printf "%-16s - %s\n", $1, $4
> }
> BEGIN{FS="\n"; RS=""}
> {
>
myprint()
> }' data2
Riley Mullen
- (312)555-1234
Frank Williams
- (317)555-9876
Haley Snell
- (313)555-4938
$
  #+end_example
-创建函数库
  与其他编程语言一样函数库说到底就是个文件,所以我们若想写一个函数库并调用它,
  只需要在执行gawk命令时像引进文件一样引进函数库即可
  例如:gawk -f 函数库 -f gawk命令文件  data.txt
** DONE RegExp
CLOSED: [2022-11-27 日 15:51]
:PROPERTIES:
:EXPORT_FILE_NAME: regexp
:END:
:LOGBOOK:
- State "DONE"       from "TODO"       [2022-11-27 日 15:51]
:END:
*** 匹配单个字符
**** .符号
  '.'符号含义为匹配任意字符,包括其本身
**** \符号
  '\'符号为转义字符,能够与特定字符组合产生特殊含义
  正则表达式中有特殊含义的字符都可以使用'\'表示其本身的意思
  例如'.'符号在正则表达式中表匹配任一字符,但若想表示'.'本身这是就能使用'\.'进行转义了
  包括'\'本身也是一样,若想表示'\'本身则需使用'\\'
  | 组合 | 描述        |
  |------+-------------|
  | \\   | 表示'\'本身 |
  | \.   | 表示'.'本身 |
  | \n   | 表换行符    |
  | \t   | 表示制表符  |
*** 匹配一组字符
**** [字符集合]使用
  [字符集合]中通常包含的是某些字符的集合,其含义为匹配这些字符的其中一个
  例如:
  '[abc]\.txt'
  其匹配结果可以是
  a.txt或b.txt或c.txt
**** [区间]使用
  当我们想匹配字母或数字时,若使用[字符集合]的表示方式就成了[abc...xyz]
  这样书写太过麻烦,因此正则表达式提供了一种区间表示方式,它能使用ASCII码的值来表示区间
  [a-z]与[abc...xyz]等价
  [0-9]与[0123456789]等价
  注意:区间可以是任意ASCII码从小到大的区间
  例如:[3-7],[c-f],[F-H]是合法
  并且由于排序是按ASCII码排序的所以
  [1-Z],[1-=]也是合法的
  因为'1'的ASCII码值为49,而'Z'和'='的ASCII码值分别为61,90,两者的ASCII的值都比'1'的ASCII码值大,因此是合法的
  但通常来说这样的表达式也不会怎么出现,使用最多的还是[0-9],[a-z],[A-Z]分别表示数字,所有小写字母和所以大写字母
  同时[区间]也能同时指定多个区间
  例如[0-9a-zA-Z]表示所以数字和字母
**** ^取反字符
'^'字符可配合中括号[]使用,表示匹配不再集合中的字符
例如[^0-9]表示匹配不是数字的字符
*** 使用元字符
在正则表达式中一个字符的含义不能表示它本身的字符就称为元字符,
前面所学的'.'表任意字符,'['和']'也都是元字符,分别表示字符集合开始和结束
它们都没有表示字符本身含义的能力,要想表示其本身就需要用前面学的'\'字符进行转义
**** 匹配空白字符
| 元字符 | 描述                              |
|--------+-----------------------------------|
| [\b]   | 回退(并删除)一个字符(BackSpace键) |
| \f     | 分页符                            |
| \r     | 回车符                            |
| \n     | 换行符                            |
| \t     | 制表符                            |
| \v     | 垂直制表符                        |
**** 匹配特定字符
***** 匹配数字
| 元字符 | 描述                     |
|--------+--------------------------|
| \d     | 匹配一个数字(等价于[0-9])  |
| \D     | 匹配一个非数字(等价于[^0-9])  |
***** 匹配数字与字母
| 元字符 | 描述                                                  |
|--------+-------------------------------------------------------|
| \w     | 匹配一个数字或字母或下划线的字符(等价于[0-9a-zA-Z_])  |
| \W     | 匹配一个非字母,数字,下划线的字符(等价于[^0-9a-zA-Z_]) |
***** 匹配空白字符
| 元字符 | 描述                                        |
|--------+---------------------------------------------|
| \s     | 匹配任意一个空白字符(等价于[\f\n\r\t\v])    |
| \S     | 匹配任意一个非空白字符(等价于[^\f\n\r\t\v]) |
**** POSIX字符类
| 字符类     | 描述                                   |
|------------+----------------------------------------|
| [:alnum:]  | 等价于[a-zA-Z0-9]                      |
| [:alpha:]  | 等价于[a-zA-Z]                         |
| [:blankl:] | 等价于[\t ]                            |
| [:cntrl:]  | 匹配ASCII的控制符(0-31加上127)         |
| [:digit:]  | 等价于[0-9]                            |
| [:graph:]  | 和[:print:]一样,但不包括空格           |
| [:low:]    | 等价于[a-z]                            |
| [:print:]  | 任何一个可打印的字符                   |
| [:punct:]  | 不属于[:alnum:]和[:cntrl:]的字符       |
| [:space:]  | 等价于[\f\b\r\t\v ]                    |
| [:upper:]  | 等价于[A-Z]                            |
| [:xdigit:] | 任何一个16进制的数字,等价于[a-fA-f0-9] |
注意:上述POSIX字符类使用时要以'[ ['开头以']]'结尾,即使用双中括号
#+begin_example example
正确写法
[[:alnum:]]
错误写法
[:alnum:]
#+end_example
*** 重复匹配
当我们想匹配'aaaaa'时,此时我们需要写5个a,如果要匹配更多的a则需要写更多,这样未免太过麻烦
因此正则表达式提供了重复匹配的办法
**** 常用重复匹配字符
- 匹配一个或多个字符
  在字符(或字符集合)后加上 *+* 作为后缀即可,
  例如:[0-9]+ 表示匹配一个或多个数字
- 匹配0个或多个字符
  使用'*'字符,用法与'+'字符相同
- 匹配0个或多1个字符
  使用'?'字符,用法与'+'字符相同
**** 重复匹配次数
上面所说的元字符依然没办法解决根本问题,例如我们指定就需要将某个字符匹配10次,
这是上面的字符就不能实现了,一次正则表达式提供了可以指定匹配次数的元字符
- 精准匹配次数
  在字符(或字符集合)后加上'{匹配次数}'即可实现精准的匹配次数
  例如:a{5} 表示匹配5个a
- 为匹配次数设置区间
  使用'{最小匹配次数,最大匹配次数}'
- 至少重复几次
  {最少匹配次数,}
  {3,}表示最少重复3次
**** 防止过度匹配
在HTML中若我们需要对一个标签中的内容进行匹配,
例如:匹配以下html代码中两个p标签内容
#+begin_src html
  fsdaf<p>aaaaa</p>
  fsdfds<p>bbbbb</p>fdsffd
#+end_src
若利用前面所学的内容我们可以写出对应的正则表达式
'<[pP]>.*</[pP]>'
然而此正则表达式匹配的内容为
#+begin_example te
<p>aaaaa</p>
fsdfds<p>bbbbb</p>
#+end_example
显然与我们预期结果不符,这是因为前面所学的'+','*','{n, }'都属于'贪婪型'匹配字符,即他们会尽可能匹配多的字符,
而我们现在需要让他们匹配到一个就结束,而不是一直匹配到结尾,此时就需要用到'惰性型'匹配字符',前面列出的'贪婪型'匹配字符,都有对应的'惰性型'匹配字符的版本
| 贪婪型元字符 | 惰性型元字符 |
|--------------+--------------|
| *            | *?           |
| +            | +?           |
| {n, }        | {n, }?       |
*** 位置匹配
**** 单词边界
- 适用场景
  当我们需要精准匹配一个单词时可以用'\b'作为单词的边界(即单词的开始和结尾)像'\b单词\b'这样
- 例1
  但我们需要匹配单词'cat'时,而不希望匹配到'scatter'这类含有'cat'字串的单词
  此时就可以用'\bcat\b'
- 注意
  '/b'它会匹配一个能够构成单词的字符(数字,字母,下划线)和一个不能构成单词的位置之间
- 例2
  this cat scatter his food
  此时文本中'cat'的'c'和't'这两位置本身是个字母,所以它是个能构成单词的位置,
  而'c'的前面和't'的后面是一个空格,属于不能构成单词的位置,所以若使用'\bcat\b'
  则'\b'的位置分别会位于'cat'和其前面的空格之间,和'cat'和其后面的空格之间
- 例3
  this - nine-digit test
  若此时我们想匹配以空格作为边界的'-'字符,此时若使用'\b-\b'它将匹配'nine-digit'中的'-'
  因为此时'nine-digit'中的'-',其本身是个不能构成单词的字符,而其前后又都是能够构成单词的字符'e'和'd'
  所以'\b-\b'中的'\b'将分别位于'e'和'-'之间和'-'和'd'之间,
  而对于文本中单独的那个'-'由于其本身是个不能构成单词的字符,而其前后又都是空格(不能够构成单词的字符)所以不能匹配
  那么如何匹配到文本中的单个'-'呢?
- \B边界
  对于上面的例子,若想匹配单个'-'则可以使用'\B'作为单词的边界
  '\B'匹配前后都不是一个能够成单词的位置
**** 字符串边界
- ^符号
  '^'表示匹配文本开头
- $符号
  '$'表示匹配文本结尾
在我们使用的地方最常用的就是xml文档校验了
因为xml文档通常以<?xml ... ?>开头此时我们可以使用正则表达式校验xml文档是否规范
'^\s*<\?xml.*?\?>'使用该正则表达式即可实现
其中'^\s*'表示允许文档开头有空格换行等空白字符,再者就是注意要使用'惰性型'匹配符
其次我们可以用于检验html文件的结束标志
使用'</[hH][tT][mM][lL]>\s*$'即可
***** 分行匹配模式
上述的'^'和'$'不仅可以匹配文档开头和结尾,在特殊元字符的帮助下可以使其作用改变为匹配一行的开头和结尾
这个元字符就是'(?m)',在正则表达式的最前面加上该元字符,就会使得原来正则表达式将整篇文档作为一个字符串
而使用该元字符后会将每行作为一个字符串从而实现上述效果
示例:检测C语言中的注释
'(?m)^\s*//.*$'可以实现检测C语言注释
*** 使用子表达式
**** 子表达式
设想我们需要使得一个单词(例如cat)出现的次数,此时就可以使用子表达式'()'即括号,将cat括起来即(cat),然后在使用前面学的重复匹配即可
例如我们希望'cat'出现10次,那么就可以使用'(cat){10}'来实现
同时子表达式也支持'|'或操作符,
例如我们希望'cat'或'dog'出现10次,那么就可以使用'(cat|dog){10}'来实现
**** 子表达式嵌套
子表达式也支持嵌套操作,这里拿一个ip地址校验举例
(((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5]))\.){3}(((\d{1,2})|(1\d{1,2})|(2[0-4]\d)|(25[0-5])))
*** 回溯应用
**** 回溯引用匹配
在正则表达式中存在一个元字符'\编号'可以引用前面子表达式匹配的内容
其中'\1'表示引用第一个子表达式匹配的内容,'\2'表示引用第二个子表达式匹配的内容,以此类推
例如:在html中我们希望找到div标签的内容
<(div)>.*?</\1>
此表达式中'\1'就代表第一个子表达式匹配的内容,由于此表达式的第一个子表达式为'(div)',
匹配的是'div'所以'\1'处其实就代表匹配'div'
*** 前后查找
在html中我们有时需要获取一个标签的内容而包含标签本身,拿div举例来说
我们需要获取div标签中的内容,但内容又不包含div标签本身(即<div>和</div>)
换句话说我们需要用div标签来匹配内容,但我们又不希望div标签出现在匹配结果中
这时就可以使用前后查找
**** 向前查找
向前查找一个必须匹配但不在返回结果中的的模式
其使用方式为一个子表达式以'?='开头'
例如:我们希望提取一下文本中url协议
#+begin_example url
https://www.baidu.com
http://www.google.com
ftp://jfdslakjf
#+end_example
分析:此时我们匹配':'前的文本,所以我们需要使用':'来匹配我们需要的内容,但我们又不希望':'出现在匹配结果中
此时就可以使用向前查找
.+(?=:)
(?=:)就可以表示用':'匹配但':'又不在匹配结果中
**** 向后查找
向后查找使用'?<=',使用方式与向前查找一样,但效果相反
**** 向前向后结合查找
使用向前向后结合查找,就能实现本章前面说的查找div标签中的内容
例如:查找以下文本div标签的内容
#+begin_src html
    <html>
      <body>
        fsdfa
        <div>aaaaaaaaaa</div>
                <div>bbbbbbbbbbbb</div>
        <div>ccccccccccccccc</div>
        </body>
  </html>
#+end_src
表达式:(?<=<div>).*?(?=</div>)
匹配结果:
aaaaaaaaaa
bbbbbbbbbbbb
ccccccccccccccc
**** 前后查找取非
取非即查找不与给定模式匹配的内容,向前向后查找与其取非的操作符如下
| 操作符 | 说明           |
|--------+----------------|
| (?=)   | 向前查找       |
| (?!)   | 向前查找的取非 |
| (?<=)  | 向后查找       |
| (?<!)    | 向后查找取非   |
例如:找出不义'$'开头的数字
#+begin_example upper
i paid $100 for 80 apple 50 orange
and 60 pear
i save $20  on this order
#+end_example
此时若我们使用向后查找
\b(?<=\$)\d+\b
将匹配100和20,因为我们查找的是以'$'开头的数字
而若使用其取反的版本
\b(?<!\$)\d+\b
将匹配80,50和60
*** 嵌入条件
条件表达式用'?'符号表示,虽然前面学过'?'表达式可用于表示字符出现0次或1次
但这并不影响使用,因为使用条件表达式的情况就两种
1. 在回溯引用中使用
2. 在前后匹配中使用
**** 回溯引用条件
在北美的电话号码中(123)456-7890,123-456-7890都是正确的
而若想实现匹配这个电话号码的正则表达式就可以用到回溯条件
解析:我梦可以将上面电话理解为若开头出现了'(',那么第5个字符就必须匹配一个')'
若开头没有'('则电话的第4个字符匹配'-'
其使用方式为(?(backreference)true-regexp[|false-regexp])
其中backreference为一个回溯引用,而true-regexp则是当其前面的回溯引用存在时才会执行的表达式
而中括号中的内容可有可无,它表示如果前面回溯引用不存在是执行的表达式
这样我们就能解决电话号码这个问题
(\()?\d{3}(?(\1)\)|-)\d{3}-\d{4}
**** 前后匹配条件
格式:(?(前后匹配条件)true|false)
*** 常用元字符
[[~/music/img/regexp.png][常用元字符]]
